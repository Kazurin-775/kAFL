From c7d3dd33ca9d1e7c16e689d5d1992bafdc8de2cd Mon Sep 17 00:00:00 2001
From: Kazurin Nanako <71819243+Kazurin-775@users.noreply.github.com>
Date: Fri, 29 Mar 2024 11:01:54 +0800
Subject: Add experimental QEMU-PT patches

---
 accel/kvm/kvm-all.c           |  82 +++++
 compile.sh                    |  19 ++
 configure                     |  13 +
 hmp-commands-pt.hx            |  99 ++++++
 hmp-commands.hx               |  11 +
 include/hw/core/cpu.h         |  25 ++
 include/monitor/hmp.h         |  11 +
 include/sysemu/runstate.h     |   3 +
 linux-headers/linux/kvm.h     |  50 +++
 meson.build                   |   4 +
 meson_options.txt             |   3 +
 monitor/hmp-target.c          |  10 +
 monitor/hmp.c                 | 210 ++++++++++++
 pt/decoder.c                  | 584 +++++++++++++++++++++++++++++++
 pt/decoder.h                  |  83 +++++
 pt/disassembler.c             | 461 +++++++++++++++++++++++++
 pt/disassembler.h             |  86 +++++
 pt/filter.c                   | 121 +++++++
 pt/filter.h                   |  62 ++++
 pt/hypercall.c                | 359 +++++++++++++++++++
 pt/hypercall.h                |  92 +++++
 pt/interface.c                | 281 +++++++++++++++
 pt/interface.h                |  54 +++
 pt/khash.h                    | 627 ++++++++++++++++++++++++++++++++++
 pt/logger.c                   | 113 ++++++
 pt/logger.h                   |  56 +++
 pt/memory_access.c            | 115 +++++++
 pt/memory_access.h            |  34 ++
 pt/meson.build                |  16 +
 pt/pt.c                       | 353 +++++++++++++++++++
 pt/pt.h                       |  38 +++
 pt/tnt_cache.c                | 148 ++++++++
 pt/tnt_cache.h                |  61 ++++
 scripts/meson-buildoptions.sh |   3 +
 softmmu/runstate.c            |  71 ++++
 softmmu/vl.c                  |   9 +-
 36 files changed, 4366 insertions(+), 1 deletion(-)
 create mode 100644 compile.sh
 create mode 100644 hmp-commands-pt.hx
 create mode 100644 pt/decoder.c
 create mode 100644 pt/decoder.h
 create mode 100644 pt/disassembler.c
 create mode 100644 pt/disassembler.h
 create mode 100644 pt/filter.c
 create mode 100644 pt/filter.h
 create mode 100644 pt/hypercall.c
 create mode 100644 pt/hypercall.h
 create mode 100644 pt/interface.c
 create mode 100644 pt/interface.h
 create mode 100644 pt/khash.h
 create mode 100644 pt/logger.c
 create mode 100644 pt/logger.h
 create mode 100644 pt/memory_access.c
 create mode 100644 pt/memory_access.h
 create mode 100644 pt/meson.build
 create mode 100644 pt/pt.c
 create mode 100644 pt/pt.h
 create mode 100644 pt/tnt_cache.c
 create mode 100644 pt/tnt_cache.h

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index cf3a88d..b29250d 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -52,6 +52,11 @@
 #include "hw/boards.h"
 #include "sysemu/stats.h"
 
+#ifdef CONFIG_PROCESSOR_TRACE
+#include "pt/pt.h"
+#include "pt/hypercall.h"
+#endif
+
 /* This check must be after config-host.h is included */
 #ifdef CONFIG_EVENTFD
 #include <sys/eventfd.h>
@@ -408,6 +413,10 @@ int kvm_init_vcpu(CPUState *cpu, Error **errp)
     cpu->dirty_pages = 0;
     cpu->throttle_us_per_full = 0;
 
+#ifdef CONFIG_PROCESSOR_TRACE
+    pt_kvm_init(cpu);
+#endif
+
     mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);
     if (mmap_size < 0) {
         ret = mmap_size;
@@ -2915,6 +2924,17 @@ int kvm_cpu_exec(CPUState *cpu)
     do {
         MemTxAttrs attrs;
 
+#ifdef CONFIG_PROCESSOR_TRACE
+        if (cpu->reload_pending) {
+            cpu->reload_pending = false;
+            //cpu_synchronize_state(cpu);
+            kvm_cpu_synchronize_state(cpu);
+            qemu_system_reload_request();
+            qemu_mutex_lock_iothread();
+            return 0;
+        }
+#endif
+
         if (cpu->vcpu_dirty) {
             kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
             cpu->vcpu_dirty = false;
@@ -2931,6 +2951,12 @@ int kvm_cpu_exec(CPUState *cpu)
             kvm_cpu_kick_self();
         }
 
+#ifdef CONFIG_PROCESSOR_TRACE
+        //if (pt_hypercalls_enabled()) {
+            pt_pre_kvm_run(cpu);
+        //}
+#endif
+
         /* Read cpu->exit_request before KVM_RUN reads run->immediate_exit.
          * Matching barrier in kvm_eat_signals.
          */
@@ -3055,11 +3081,67 @@ int kvm_cpu_exec(CPUState *cpu)
                 break;
             }
             break;
+#ifdef CONFIG_PROCESSOR_TRACE
+        case KVM_EXIT_KAFL_ACQUIRE:
+            handle_hypercall_kafl_acquire(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_GET_PAYLOAD:
+            handle_hypercall_get_payload(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_GET_PROGRAM:
+            handle_hypercall_get_program(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_RELEASE:
+            handle_hypercall_kafl_release(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_SUBMIT_CR3:
+            handle_hypercall_kafl_cr3(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_SUBMIT_PANIC:
+            handle_hypercall_kafl_submit_panic(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_SUBMIT_KASAN:
+            handle_hypercall_kafl_submit_kasan(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_PANIC:
+            handle_hypercall_kafl_panic(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_KASAN:
+            handle_hypercall_kafl_kasan(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_LOCK:
+            handle_hypercall_kafl_lock(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_INFO:
+            handle_hypercall_kafl_info(run, cpu);
+            ret = 0;
+            break;
+        case KVM_EXIT_KAFL_NEXT_PAYLOAD:                                                                                                                                     
+            handle_hypercall_kafl_next_payload(run, cpu);                                                                                                                    
+            ret = 0;                                                                                                                                                         
+            break;                                                                                                                                                                                                                                                                                                              
+#endif
         default:
             DPRINTF("kvm_arch_handle_exit\n");
             ret = kvm_arch_handle_exit(cpu, run);
             break;
         }
+
+#ifdef CONFIG_PROCESSOR_TRACE
+        //if (pt_hypercalls_enabled()) {
+            pt_post_kvm_run(cpu);
+        //}
+#endif
     } while (ret == 0);
 
     cpu_exec_end(cpu);
diff --git a/compile.sh b/compile.sh
new file mode 100644
index 0000000..176e9e7
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,19 @@
+# Copyright (C) 2017 Sergej Schumilo
+# 
+# This file is part of QEMU-PT (kAFL).
+# 
+# QEMU-PT is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+# 
+# QEMU-PT is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+./configure --target-list=x86_64-softmmu --enable-gtk --enable-pt
+make -j $(nproc)
diff --git a/configure b/configure
index a62a3e6..64a5f4b 100755
--- a/configure
+++ b/configure
@@ -824,6 +824,10 @@ for opt do
   ;;
   --enable-tcg) tcg="enabled"
   ;;
+  --disable-pt) pt="no"
+  ;;
+  --enable-pt) pt="yes"
+  ;;
   --disable-system) softmmu="no"
   ;;
   --enable-system) softmmu="yes"
@@ -2238,6 +2242,11 @@ if test "$fortify_source" = "yes" ; then
   QEMU_CFLAGS="-U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $QEMU_CFLAGS"
 fi
 
+if test "$pt" = "yes" ; then
+  # `-fno-fast-math` fixes `fpu/softfloat.c`
+  QEMU_CFLAGS="-Ofast -march=native -mtune=haswell -fno-fast-math $QEMU_CFLAGS"
+fi
+
 if test "$have_asan" = "yes"; then
   QEMU_CFLAGS="-fsanitize=address $QEMU_CFLAGS"
   QEMU_LDFLAGS="-fsanitize=address $QEMU_LDFLAGS"
@@ -2402,6 +2411,10 @@ if test "$have_tsan" = "yes" && test "$have_tsan_iface_fiber" = "yes" ; then
     echo "CONFIG_TSAN=y" >> $config_host_mak
 fi
 
+if test "$pt" = "yes" ; then
+  echo "CONFIG_PROCESSOR_TRACE=y" >> $config_host_mak
+fi
+
 if test "$plugins" = "yes" ; then
     echo "CONFIG_PLUGIN=y" >> $config_host_mak
 fi
diff --git a/hmp-commands-pt.hx b/hmp-commands-pt.hx
new file mode 100644
index 0000000..eb907c2
--- /dev/null
+++ b/hmp-commands-pt.hx
@@ -0,0 +1,99 @@
+/*
+
+ Copyright (C) 2017 Sergej Schumilo
+ 
+ This file is part of QEMU-PT (kAFL).
+ 
+ QEMU-PT is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+ 
+ QEMU-PT is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+HXCOMM Use DEFHEADING() to define headings in both help text and texi
+HXCOMM Text between STEXI and ETEXI are copied to texi version and
+HXCOMM discarded from C version
+HXCOMM DEF(command, args, callback, arg_string, help) is used to construct
+HXCOMM monitor info commands
+HXCOMM HXCOMM can be used for comments, discarded from both texi and C
+
+SRST
+``info`` *subcommand*
+  Show various information about the system state.
+
+ERST
+
+#if defined(CONFIG_PROCESSOR_TRACE) && defined(TARGET_X86_64)
+
+{
+    .name       = "enable",
+    .args_type  = "id:i",
+    .params     = "id",
+    .help       = "enable processor tracing for specified vcpu",
+    .cmd  = hmp_pt_enable,
+},
+{
+    .name       = "enable_all",
+    .args_type  = "",
+    .params     = "",
+    .help       = "enable processor tracing for all presented vcpus",
+    .cmd  = hmp_pt_enable_all,
+},
+{
+    .name       = "disable",
+    .args_type  = "id:i",
+    .params     = "id",
+    .help       = "disable processor tracing for specified vcpu",
+    .cmd  = hmp_pt_disable,
+},
+{
+    .name       = "disable_all",
+    .args_type  = "",
+    .params     = "",
+    .help       = "disable processor tracing for all presented vcpus",
+    .cmd  = hmp_pt_disable_all,
+},
+{
+    .name       = "status",
+    .args_type  = "id:i",
+    .params     = "id",
+    .help       = "print processor tracing status of specified vcpu",
+    .cmd  = hmp_pt_status,
+},
+{
+    .name       = "status_all",
+    .args_type  = "",
+    .params     = "",
+    .help       = "print processor tracing status of all presented vcpus",
+    .cmd  = hmp_pt_status_all,
+},
+{
+    .name       = "ip_filtering",
+    .args_type  = "id:i,addrn:i,addr_a:l,addr_b:l",
+    .params     = "id addrn (0-4) addr_a addr_b",
+    .help       = "enables ip-filtering for specified vcpu",
+    .cmd  = hmp_pt_ip_filtering,
+},
+{
+    .name       = "set_file",
+    .args_type  = "file:s",
+    .params     = "file",
+    .help       = "set output file for all specified vcpu (postfix: _cpuid)",
+    .cmd  = hmp_pt_set_file,
+},
+        
+#endif
+
+SRST
+  ``info version``
+    Show the version of QEMU.
+ERST
diff --git a/hmp-commands.hx b/hmp-commands.hx
index bb85ee1..9d7c24b 100644
--- a/hmp-commands.hx
+++ b/hmp-commands.hx
@@ -1846,3 +1846,14 @@ SRST
   List event channels in the guest
 ERST
 #endif
+
+#if defined(CONFIG_PROCESSOR_TRACE) && defined(TARGET_X86_64)
+    {
+        .name       = "pt",
+        .args_type  = "item:s?",
+        .params     = "[subcommand]",
+        .help       = "show various option to configure Intel Processor Tracing",
+        .cmd        = hmp_info_help,
+        .sub_table  = hmp_pt_cmds,
+    },
+#endif
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index 397fd3a..c0ad71a 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -392,6 +392,31 @@ struct CPUState {
      */
     uintptr_t mem_io_pc;
 
+#ifdef CONFIG_PROCESSOR_TRACE
+    volatile int pt_cmd;
+    volatile uint64_t pt_arg;
+    volatile int pt_ret;
+    volatile bool pt_enabled;
+
+    int pt_fd;
+    void* pt_mmap;
+
+    volatile uint32_t overflow_counter;
+    volatile uint64_t trace_size;
+
+    uint64_t pt_features;
+
+    volatile bool pt_ip_filter_enabled[4];
+    uint64_t pt_ip_filter_a[4];
+    uint64_t pt_ip_filter_b[4];
+    void* pt_decoder_state[4];
+    uint64_t pt_c3_filter;
+
+    FILE *pt_target_file;
+    bool reload_pending;
+
+#endif
+
     /* Only used in KVM */
     int kvm_fd;
     struct KVMState *kvm_state;
diff --git a/include/monitor/hmp.h b/include/monitor/hmp.h
index fdb69b7..d980874 100644
--- a/include/monitor/hmp.h
+++ b/include/monitor/hmp.h
@@ -17,6 +17,17 @@
 #include "qemu/readline.h"
 #include "qapi/qapi-types-common.h"
 
+#ifdef CONFIG_PROCESSOR_TRACE
+void hmp_pt_enable(Monitor *mon, const QDict *qdict);
+void hmp_pt_disable(Monitor *mon, const QDict *qdict);
+void hmp_pt_enable_all(Monitor *mon, const QDict *qdict);
+void hmp_pt_disable_all(Monitor *mon, const QDict *qdict);
+void hmp_pt_status(Monitor *mon, const QDict *qdict);
+void hmp_pt_status_all(Monitor *mon, const QDict *qdict);
+void hmp_pt_ip_filtering(Monitor *mon, const QDict *qdict);
+void hmp_pt_set_file(Monitor *mon, const QDict *qdict);
+#endif
+
 bool hmp_handle_error(Monitor *mon, Error *err);
 void hmp_help_cmd(Monitor *mon, const char *name);
 strList *hmp_split_at_comma(const char *str);
diff --git a/include/sysemu/runstate.h b/include/sysemu/runstate.h
index f3ed525..d64a6c5 100644
--- a/include/sysemu/runstate.h
+++ b/include/sysemu/runstate.h
@@ -54,6 +54,9 @@ typedef enum WakeupReason {
 } WakeupReason;
 
 void qemu_system_reset_request(ShutdownCause reason);
+#ifdef CONFIG_PROCESSOR_TRACE
+void qemu_system_reload_request(void);
+#endif
 void qemu_system_suspend_request(void);
 void qemu_register_suspend_notifier(Notifier *notifier);
 bool qemu_wakeup_suspend_enabled(void);
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 1e2c16c..2bc82e5 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -265,6 +265,24 @@ struct kvm_xen_exit {
 #define KVM_EXIT_RISCV_CSR        36
 #define KVM_EXIT_NOTIFY           37
 
+#define HYPERCALL_KAFL_RAX_ID                   0x01f
+#define KVM_EXIT_KAFL_ACQUIRE                   100
+#define KVM_EXIT_KAFL_GET_PAYLOAD               101
+#define KVM_EXIT_KAFL_GET_PROGRAM               102
+#define KVM_EXIT_KAFL_GET_ARGV                  103
+#define KVM_EXIT_KAFL_RELEASE                   104
+#define KVM_EXIT_KAFL_SUBMIT_CR3                105
+#define KVM_EXIT_KAFL_SUBMIT_PANIC              106
+#define KVM_EXIT_KAFL_SUBMIT_KASAN              107
+#define KVM_EXIT_KAFL_PANIC                             108
+#define KVM_EXIT_KAFL_KASAN                             109
+#define KVM_EXIT_KAFL_LOCK                              110
+#define KVM_EXIT_KAFL_INFO                              111
+#define KVM_EXIT_KAFL_NEXT_PAYLOAD              112
+#define KVM_EXIT_KAFL_DEBUG                             113
+#define KVM_EXIT_KAFL_HOOK                              114
+#define KVM_EXIT_KAFL_MTF                               115
+
 /* For KVM_EXIT_INTERNAL_ERROR */
 /* Emulate instruction failed. */
 #define KVM_INTERNAL_ERROR_EMULATION	1
@@ -2226,4 +2244,36 @@ struct kvm_s390_zpci_op {
 /* flags for kvm_s390_zpci_op->u.reg_aen.flags */
 #define KVM_S390_ZPCIOP_REGAEN_HOST    (1 << 0)
 
+/*
+ * ioctls for vmx_pt fds
+ */
+#define KVM_VMX_PT_SETUP_FD                                     _IO(KVMIO,      0xd0)                   /* apply vmx_pt fd (via vcpu fd ioctl)*/
+#define KVM_VMX_PT_CONFIGURE_ADDR0                      _IOW(KVMIO,     0xd1, __u64)    /* configure IP-filtering for addr0_a & addr0_b */
+#define KVM_VMX_PT_CONFIGURE_ADDR1                      _IOW(KVMIO,     0xd2, __u64)    /* configure IP-filtering for addr1_a & addr1_b */
+#define KVM_VMX_PT_CONFIGURE_ADDR2                      _IOW(KVMIO,     0xd3, __u64)    /* configure IP-filtering for addr2_a & addr2_b */
+#define KVM_VMX_PT_CONFIGURE_ADDR3                      _IOW(KVMIO,     0xd4, __u64)    /* configure IP-filtering for addr3_a & addr3_b */
+
+#define KVM_VMX_PT_CONFIGURE_CR3                        _IOW(KVMIO,     0xd5, __u64)    /* setup CR3 filtering value */
+#define KVM_VMX_PT_ENABLE                                       _IO(KVMIO,      0xd6)                   /* enable and lock configuration */ 
+#define KVM_VMX_PT_GET_TOPA_SIZE                        _IOR(KVMIO,     0xd7, __u32)    /* get defined ToPA size */
+#define KVM_VMX_PT_DISABLE                                      _IO(KVMIO,      0xd8)                   /* enable and lock configuration */ 
+#define KVM_VMX_PT_CHECK_TOPA_OVERFLOW          _IO(KVMIO,      0xd9)                   /* check for ToPA overflow */
+
+#define KVM_VMX_PT_ENABLE_ADDR0                         _IO(KVMIO,      0xaa)                   /* enable IP-filtering for addr0 */
+#define KVM_VMX_PT_ENABLE_ADDR1                         _IO(KVMIO,      0xab)                   /* enable IP-filtering for addr1 */
+#define KVM_VMX_PT_ENABLE_ADDR2                         _IO(KVMIO,      0xac)                   /* enable IP-filtering for addr2 */
+#define KVM_VMX_PT_ENABLE_ADDR3                         _IO(KVMIO,      0xad)                   /* enable IP-filtering for addr3 */
+
+#define KVM_VMX_PT_DISABLE_ADDR0                        _IO(KVMIO,      0xae)                   /* disable IP-filtering for addr0 */
+#define KVM_VMX_PT_DISABLE_ADDR1                        _IO(KVMIO,      0xaf)                   /* disable IP-filtering for addr1 */
+#define KVM_VMX_PT_DISABLE_ADDR2                        _IO(KVMIO,      0xe0)                   /* disable IP-filtering for addr2 */
+#define KVM_VMX_PT_DISABLE_ADDR3                        _IO(KVMIO,      0xe1)                   /* disable IP-filtering for addr3 */
+
+#define KVM_VMX_PT_ENABLE_CR3                           _IO(KVMIO,      0xe2)                   /* enable CR3 filtering */
+#define KVM_VMX_PT_DISABLE_CR3                          _IO(KVMIO,      0xe3)                   /* disable CR3 filtering */
+
+#define KVM_VMX_PT_SUPPORTED                            _IO(KVMIO,      0xe4)
+
+#define KVM_VMX_PT_CONFIGURE_HYPERCALL_HOOK     _IOW(KVMIO,     0xe5, __u64)    /* set address for hypercall hooks */
+
 #endif /* __LINUX_KVM_H */
diff --git a/meson.build b/meson.build
index 30447cf..913a194 100644
--- a/meson.build
+++ b/meson.build
@@ -2884,6 +2884,7 @@ hxdep = []
 hx_headers = [
   ['qemu-options.hx', 'qemu-options.def'],
   ['qemu-img-cmds.hx', 'qemu-img-cmds.h'],
+  ['hmp-commands-pt.hx', 'hmp-commands-pt.h'],
 ]
 if have_system
   hx_headers += [
@@ -3186,6 +3187,8 @@ subdir('accel')
 subdir('plugins')
 subdir('ebpf')
 
+subdir('pt')
+
 common_user_inc = []
 
 subdir('common-user')
@@ -3892,6 +3895,7 @@ if have_system
     summary_info += {'xen ctrl version':  xen.version()}
   endif
   summary_info += {'Xen emulation':     config_all.has_key('CONFIG_XEN_EMU')}
+  summary_info += {'Processor Trace support':   config_all.has_key('CONFIG_PROCESSOR_TRACE')}
 endif
 summary_info += {'TCG support':       config_all.has_key('CONFIG_TCG')}
 if config_all.has_key('CONFIG_TCG')
diff --git a/meson_options.txt b/meson_options.txt
index bc857fe..1d3dc5a 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -329,3 +329,6 @@ option('slirp_smbd', type : 'feature', value : 'auto',
 
 option('hexagon_idef_parser', type : 'boolean', value : true,
        description: 'use idef-parser to automatically generate TCG code for the Hexagon frontend')
+
+option('vmx_pt', type: 'feature', value: 'disabled',
+       description: 'Guest tracing via vmx_pt')
diff --git a/monitor/hmp-target.c b/monitor/hmp-target.c
index 1eb72ac..6bdb7c1 100644
--- a/monitor/hmp-target.c
+++ b/monitor/hmp-target.c
@@ -45,6 +45,9 @@
 #include CONFIG_DEVICES
 
 static HMPCommand hmp_info_cmds[];
+#if defined(CONFIG_PROCESSOR_TRACE)
+static HMPCommand hmp_pt_cmds[];
+#endif
 
 /**
  * Is @name in the '|' separated list of names @list?
@@ -81,6 +84,13 @@ HMPCommand hmp_cmds[] = {
     { NULL, NULL, },
 };
 
+#if defined(CONFIG_PROCESSOR_TRACE)
+static HMPCommand hmp_pt_cmds[] = {
+#include "hmp-commands-pt.h"
+    { NULL, NULL, },
+};
+#endif
+
 /*
  * Set @pval to the value in the register identified by @name.
  * return 0 if OK, -1 if not found
diff --git a/monitor/hmp.c b/monitor/hmp.c
index fee4103..b4bf8a7 100644
--- a/monitor/hmp.c
+++ b/monitor/hmp.c
@@ -38,6 +38,216 @@
 #include "sysemu/block-backend.h"
 #include "trace.h"
 
+#if defined(CONFIG_PROCESSOR_TRACE)
+#include "hw/core/cpu.h"
+#include "pt/pt.h"
+#include "qapi/qapi-commands-machine.h"
+
+static inline bool hmp_pt_check_kvm(Monitor *mon){
+        KvmInfo *info;
+        info = qmp_query_kvm(NULL);
+        
+        if (!info->enabled){
+                monitor_printf(mon, "kvm is not used...\n");
+                qapi_free_KvmInfo(info);
+                return false;
+        }        
+        qapi_free_KvmInfo(info);
+        return true;
+}
+
+static inline int hmp_pt_get_cpuid(Monitor *mon, const QDict *qdict){
+        int cpuid = qdict_get_int(qdict, "id");    
+        if(cpuid < 0 || !qemu_get_cpu(cpuid)){
+                monitor_printf(mon, "invalid CPU id\n");
+                cpuid = -1;
+        }
+        return cpuid;
+}
+
+static inline void hmp_pt_enable_cpu(Monitor *mon, int cpuid){
+    CPUState *cpu = qemu_get_cpu(cpuid);
+    if (!cpu->pt_enabled){
+        if(!pt_enable(qemu_get_cpu(cpuid), true)){
+            monitor_printf(mon, "CPU %d: processor trace enabled!\n", cpuid);
+        }
+        else{
+            monitor_printf(mon, "CPU %d: failed...\n", cpuid);
+        }
+    }
+}
+
+static inline void hmp_pt_disable_cpu(Monitor *mon, int cpuid){
+    CPUState *cpu = qemu_get_cpu(cpuid);
+    if (cpu->pt_enabled){
+        if(!pt_disable(qemu_get_cpu(cpuid), true)){
+            monitor_printf(mon, "CPU %d: processor trace disabled!\n", cpuid);
+        }
+        else{
+            monitor_printf(mon, "CPU %d: failed...\n", cpuid);
+        }
+    }
+}
+
+static inline void hmp_pt_enable_ip_filtering_cpu(Monitor *mon, int cpuid, int addrn, uint64_t addr_a, uint64_t addr_b){
+        if(!pt_enable_ip_filtering(qemu_get_cpu(cpuid), addrn, addr_a, addr_b, true)){
+            monitor_printf(mon, "CPU %d: ip filtering enabled...\n", cpuid);
+        }
+        else{
+            monitor_printf(mon, "CPU %d: failed...\n", cpuid);
+        }
+}
+
+
+static inline void hmp_pt_status_cpu(Monitor *mon, int cpuid){
+        int i;
+        CPUState *cpu = qemu_get_cpu(cpuid);
+        monitor_printf(mon, "Processor Trace Status (CPU %d)\n", cpuid);
+        if (cpu->pt_enabled){
+                monitor_printf(mon, "\tenabled:\t\tyes\n");
+        }
+        else{
+                monitor_printf(mon, "\tenabled:\t\tno\n");
+        }
+        monitor_printf(mon, "\tToPA overflows:\t\t%u\n", cpu->overflow_counter);
+        monitor_printf(mon, "\ttrace data size:\t%lu (%luMB)\n", cpu->trace_size, cpu->trace_size >> 20);
+
+        for(i = 0; i < 4; i++){
+                if (cpu->pt_ip_filter_enabled[i]){
+                        switch(i){
+                                case 0:
+                                case 1:
+                                case 2:
+                                case 3:
+                                        monitor_printf(mon, "\tpt_ip_filter_%d_a:\t0x%016lx\n", i, cpu->pt_ip_filter_a[i]);
+                                        monitor_printf(mon, "\tpt_ip_filter_%d_b:\t0x%016lx\n", i, cpu->pt_ip_filter_b[i]);
+                                        break;
+                        }
+                }        
+        }
+}
+
+void hmp_pt_enable(Monitor *mon, const QDict *qdict)
+{
+        int cpuid = hmp_pt_get_cpuid(mon, qdict);
+        if (!hmp_pt_check_kvm(mon) || (cpuid < 0))
+                return;
+        hmp_pt_enable_cpu(mon, cpuid);
+}
+
+void hmp_pt_disable(Monitor *mon, const QDict *qdict)
+{
+        int cpuid = hmp_pt_get_cpuid(mon, qdict);
+        if (!hmp_pt_check_kvm(mon) || (cpuid < 0))
+                return;
+        hmp_pt_disable_cpu(mon, cpuid);
+}
+
+void hmp_pt_enable_all(Monitor *mon, const QDict *qdict)
+{
+        int cpuid;
+        CpuInfoFastList *cpu_list, *cpu;
+        
+        if (!hmp_pt_check_kvm(mon))
+                return;
+        
+        cpu_list = qmp_query_cpus_fast(NULL);
+        for (cpu = cpu_list; cpu; cpu = cpu->next) {
+                cpuid = cpu->value->cpu_index;    
+                if (!(monitor_set_cpu(mon, cpuid) < 0))
+                        hmp_pt_enable_cpu(mon, cpuid);
+        }
+        qapi_free_CpuInfoFastList(cpu_list);
+}
+
+void hmp_pt_disable_all(Monitor *mon, const QDict *qdict)
+{
+        int cpuid;
+        CpuInfoFastList *cpu_list, *cpu;
+        
+        if (!hmp_pt_check_kvm(mon))
+                return;
+        
+        cpu_list = qmp_query_cpus_fast(NULL);
+        for (cpu = cpu_list; cpu; cpu = cpu->next) {
+                cpuid = cpu->value->cpu_index;    
+                if (!(monitor_set_cpu(mon, cpuid) < 0))
+                        hmp_pt_disable_cpu(mon, cpuid);
+        }
+        qapi_free_CpuInfoFastList(cpu_list);
+}
+
+void hmp_pt_status(Monitor *mon, const QDict *qdict)
+{
+        int cpuid = hmp_pt_get_cpuid(mon, qdict);
+        if (!hmp_pt_check_kvm(mon) || (cpuid < 0))
+                return;
+        hmp_pt_status_cpu(mon, cpuid);
+}
+
+void hmp_pt_status_all(Monitor *mon, const QDict *qdict)
+{
+        int cpuid;
+        CpuInfoFastList *cpu_list, *cpu;
+        
+        if (!hmp_pt_check_kvm(mon))
+                return;
+        
+        cpu_list = qmp_query_cpus_fast(NULL);
+        for (cpu = cpu_list; cpu; cpu = cpu->next) {
+                cpuid = cpu->value->cpu_index;    
+                if (!(monitor_set_cpu(mon, cpuid) < 0))
+                        hmp_pt_status_cpu(mon, cpuid);
+        }
+        qapi_free_CpuInfoFastList(cpu_list);
+}
+
+void hmp_pt_ip_filtering(Monitor *mon, const QDict *qdict)
+{
+        int cpuid, addrn;    
+        uint64_t addr_a;
+        uint64_t addr_b;
+        
+        cpuid = hmp_pt_get_cpuid(mon, qdict);
+        if (!hmp_pt_check_kvm(mon) || (cpuid < 0))
+                return;
+        
+        addrn = qdict_get_int(qdict, "addrn");
+        if(addrn < 0 || addrn >= 4){
+                monitor_printf(mon, "invalid addrn value (0-3)\n");
+                return;
+        }
+                
+        addr_a = qdict_get_int(qdict, "addr_a");
+        addr_b = qdict_get_int(qdict, "addr_b");
+            
+        hmp_pt_enable_ip_filtering_cpu(mon, cpuid, addrn, addr_a, addr_b);
+}
+
+void hmp_pt_set_file(Monitor *mon, const QDict *qdict){
+        int cpuid;
+        CpuInfoFastList *cpu_list, *cpu;
+        const char *filename = qdict_get_str(qdict, "file");
+        char* new_filename;
+               
+        if (!hmp_pt_check_kvm(mon))
+                return;
+        
+        new_filename = malloc(sizeof(char)*(strlen(filename)+12));
+        cpu_list = qmp_query_cpus_fast(NULL);
+        for (cpu = cpu_list; cpu; cpu = cpu->next) {
+                cpuid = cpu->value->cpu_index;    
+                if (!(monitor_set_cpu(mon, cpuid) < 0)){
+                        sprintf(new_filename, "%s_%d", filename, cpuid);
+                        qemu_get_cpu(cpuid)->pt_target_file = fopen(new_filename, "wb");
+                }
+        }
+        free(new_filename);
+        qapi_free_CpuInfoFastList(cpu_list);
+}
+
+#endif
+
 static void monitor_command_cb(void *opaque, const char *cmdline,
                                void *readline_opaque)
 {
diff --git a/pt/decoder.c b/pt/decoder.c
new file mode 100644
index 0000000..2799a25
--- /dev/null
+++ b/pt/decoder.c
@@ -0,0 +1,584 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+Note: 
+This Intel PT software decoder is partially inspired and based on Andi 
+Kleen's fastdecode.c (simple-pt). 
+See: https://github.com/andikleen/simple-pt/blob/master/fastdecode.c
+
+ * Simple PT dumper
+ *
+ * Copyright (c) 2015, Intel Corporation
+ * Author: Andi Kleen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define _GNU_SOURCE 1
+#include "pt/decoder.h"
+
+#define LEFT(x) ((end - p) >= (x))
+#define BIT(x) (1U << (x))
+
+#define BENCHMARK 				1
+
+#define PT_PKT_GENERIC_LEN		2
+#define PT_PKT_GENERIC_BYTE0	0b00000010
+
+#define PT_PKT_LTNT_LEN			8
+#define PT_PKT_LTNT_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_LTNT_BYTE1		0b10100011
+
+#define PT_PKT_PIP_LEN			8
+#define PT_PKT_PIP_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_PIP_BYTE1		0b01000011
+
+#define PT_PKT_CBR_LEN			4
+#define PT_PKT_CBR_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_CBR_BYTE1		0b00000011
+
+#define PT_PKT_OVF_LEN			8
+#define PT_PKT_OVF_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_OVF_BYTE1		0b11110011
+
+#define PT_PKT_PSB_LEN			16
+#define PT_PKT_PSB_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_PSB_BYTE1		0b10000010
+
+#define PT_PKT_PSBEND_LEN		2
+#define PT_PKT_PSBEND_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_PSBEND_BYTE1		0b00100011
+
+#define PT_PKT_MNT_LEN			11
+#define PT_PKT_MNT_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_MNT_BYTE1		0b11000011
+#define PT_PKT_MNT_BYTE2		0b10001000
+
+#define PT_PKT_TMA_LEN			7
+#define PT_PKT_TMA_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_TMA_BYTE1		0b01110011
+
+#define PT_PKT_VMCS_LEN			7
+#define PT_PKT_VMCS_BYTE0		PT_PKT_GENERIC_BYTE0
+#define PT_PKT_VMCS_BYTE1		0b11001000
+
+#define	PT_PKT_TS_LEN			2
+#define PT_PKT_TS_BYTE0			PT_PKT_GENERIC_BYTE0
+#define PT_PKT_TS_BYTE1			0b10000011
+
+#define PT_PKT_MODE_LEN			2
+#define PT_PKT_MODE_BYTE0		0b10011001
+
+#define PT_PKT_TIP_LEN			8
+#define PT_PKT_TIP_SHIFT		5
+#define PT_PKT_TIP_MASK			0b00011111
+#define PT_PKT_TIP_BYTE0		0b00001101
+#define PT_PKT_TIP_PGE_BYTE0	0b00010001
+#define PT_PKT_TIP_PGD_BYTE0	0b00000001
+#define PT_PKT_TIP_FUP_BYTE0	0b00011101
+
+//#define DEBUG
+
+static uint8_t psb[16] = {
+	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
+	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82
+};
+
+#ifdef DECODER_LOG
+static void flush_log(decoder_t* self){
+	self->log.tnt64 = 0;
+	self->log.tnt8 = 0;
+	self->log.pip = 0;
+	self->log.cbr = 0;
+	self->log.ts = 0;
+	self->log.ovf = 0;
+	self->log.psbc = 0;
+	self->log.psbend = 0;
+	self->log.mnt = 0;
+	self->log.tma = 0;
+	self->log.vmcs = 0;
+	self->log.pad = 0;
+	self->log.tip = 0;
+	self->log.tip_pge = 0;
+	self->log.tip_pgd = 0;
+	self->log.tip_fup = 0;
+	self->log.mode = 0;
+}
+#endif
+
+decoder_t* pt_decoder_init(uint8_t* code, uint64_t min_addr, uint64_t max_addr, void (*handler)(uint64_t)){
+	decoder_t* res = malloc(sizeof(decoder_t));
+	res->code = code;
+	res->min_addr = min_addr;
+	res->max_addr = max_addr;
+	res->handler = handler;
+
+	res->last_tip = 0;
+	res->last_ip2 = 0;
+	res->fup_pkt = false;
+	res->isr = false;
+	res->in_range = false;
+#ifdef DECODER_LOG
+	flush_log(res);
+#endif
+	res->disassembler_state = init_disassembler(code, min_addr, max_addr, handler);
+	res->tnt_cache_state = tnt_cache_init();
+	return res;
+}
+
+void pt_decoder_destroy(decoder_t* self){
+	if(self->tnt_cache_state){
+		destroy_disassembler(self->disassembler_state);
+		tnt_cache_destroy(self->tnt_cache_state);
+		self->tnt_cache_state = NULL;
+	}
+	free(self);
+}
+
+void pt_decoder_flush(decoder_t* self){
+	self->last_tip = 0;
+	self->last_ip2 = 0;
+	self->fup_pkt = false;
+	self->isr = false;
+	self->in_range = false;
+#ifdef DECODER_LOG
+	flush_log(self);
+#endif
+	/* ugly hack */
+	if(self->tnt_cache_state){
+		tnt_cache_destroy(self->tnt_cache_state);
+	}
+	self->tnt_cache_state = tnt_cache_init();
+}
+
+
+static inline uint64_t get_ip_val(unsigned char **pp, unsigned char *end, int len, uint64_t *last_ip)
+{
+	unsigned char *p = *pp;
+	uint64_t v = *last_ip;
+	int i;
+	unsigned shift = 0;
+
+	if (len == 0) {
+		return 0; /* out of context */
+	}
+	if (len < 4) {
+		if (!LEFT(len)) {
+			puts("Warning: short read when parsing TIP.* packet");
+			*last_ip = 0;
+			return 0; /* XXX error */
+		}
+		for (i = 0; i < len; i++, shift += 16, p += 2) {
+			uint64_t b = *(uint16_t *)p;
+			v = (v & ~(0xffffULL << shift)) | (b << shift);
+		}
+		v = ((int64_t)(v << (64 - 48))) >> (64 - 48); /* sign extension */
+	} else if (len == 6) {
+		v = *(uint64_t *)p;
+		p += 8;
+	} else {
+		printf("Warning: unrecognized TIP.* packet with IPBytes = %d\n", len);
+		return 0; /* XXX error */
+	}
+	*pp = p;
+	*last_ip = v;
+	return v;
+}
+
+static void print_unknown(unsigned char *p, unsigned char *end, unsigned char *map)
+{
+	printf("unknown packet: ");
+	unsigned len = end - p;
+	int i;
+	if (len > 16)
+		len = 16;
+	for (i = 0; i < len; i++)
+		printf("%02x ", p[i]);
+	printf("\n");
+}
+
+/* Caller must have checked length */
+static uint64_t get_val(unsigned char **pp, int len)
+{
+	unsigned char *p = *pp;
+	uint64_t v = 0;
+	int i;
+	unsigned shift = 0;
+
+	for (i = 0; i < len; i++, shift += 8)
+		v |= ((uint64_t)(*p++)) << shift;
+	*pp = p;
+	return v;
+}
+
+static inline void pad_handler(decoder_t* self, uint8_t** p){
+	(*p)++;
+#ifdef DECODER_LOG
+	self->log.pad++;
+#endif
+}
+
+static inline void tnt8_handler(decoder_t* self, uint8_t** p){
+	append_tnt_cache(self->tnt_cache_state, true, (uint64_t)(**p));
+	(*p)++;
+#ifdef DECODER_LOG
+	self->log.tnt8++;
+#endif
+}
+
+static inline void cyc_handler(decoder_t* self, uint8_t** p) {
+	if (**p & 4) {
+		while (**p & 1)
+			(*p)++;
+		(*p)++;
+	} else {
+		(*p)++;
+	}
+}
+
+static inline void cbr_handler(decoder_t* self, uint8_t** p){
+	(*p) += PT_PKT_CBR_LEN;
+#ifdef DECODER_LOG
+	self->log.cbr++;
+#endif
+}
+
+static inline void mode_handler(decoder_t* self, uint8_t** p){
+	sample_decoded_detailed("MODE\n");
+	(*p) += PT_PKT_MODE_LEN;
+#ifdef DECODER_LOG
+	self->log.mode++;
+#endif
+}
+
+static inline void tip_handler(decoder_t* self, uint8_t** p, uint8_t** end){
+	//if (self->fup_pkt){
+	//	sample_decoded_detailed("INTERRUPT!\n");
+	//	self->fup_pkt = false;
+	//	self->isr = true;
+	//}
+	if (count_tnt(self->tnt_cache_state)){
+		//if (trace_disassembler(self->last_tip, self->min_addr, self->max_addr, self->code, self->handler, (self->isr &!self->in_range))){
+		if (trace_disassembler(self->disassembler_state, self->last_tip, (self->isr &!self->in_range), self->tnt_cache_state)){
+			sample_decoded_detailed("IRET!\n");
+			//self->isr = false;
+		}
+	}
+	self->last_tip = get_ip_val(p, *end, (*(*p)++ >> PT_PKT_TIP_SHIFT), &self->last_ip2);
+	if(!self->last_tip)
+		printf("tip trashed 1\n");
+	sample_decoded_detailed("TIP    \t%lx\n", self->last_tip);
+#ifdef DECODER_LOG
+	self->log.tip++;
+#endif
+}
+
+static inline void tip_pge_handler(decoder_t* self, uint8_t** p, uint8_t** end){
+	self->pge_enabled = true;
+	self->last_tip = get_ip_val(p, *end, (*(*p)++ >> PT_PKT_TIP_SHIFT), &self->last_ip2);
+	if(!self->last_tip)
+		sample_decoded_detailed("tip trashed 2\n");
+	sample_decoded_detailed("TIP.PGE\t%lx\n", self->last_tip);
+	//trace_disassembler(self->last_tip, self->min_addr, self->max_addr, self->code, self->handler, (self->isr &!self->in_range));
+	trace_disassembler(self->disassembler_state, self->last_tip, (self->isr &!self->in_range), self->tnt_cache_state);
+#ifdef DECODER_LOG
+	self->log.tip_pge++;
+#endif
+}
+
+static inline void tip_pgd_handler(decoder_t* self, uint8_t** p, uint8_t** end){
+	//if (self->fup_pkt){
+	//	sample_decoded_detailed("WRITE MSR / READ MSR \n");
+	//	self->fup_pkt = false;
+	//}
+	self->pge_enabled = false;
+	if (count_tnt(self->tnt_cache_state)){
+		//if (trace_disassembler(self->last_tip, self->min_addr, self->max_addr, self->code, self->handler, (self->isr &!self->in_range))){
+		if (trace_disassembler(self->disassembler_state, self->last_tip, (self->isr &!self->in_range), self->tnt_cache_state)){
+			sample_decoded_detailed("SYSRET!\n");
+			//self->in_range = false;
+		}
+	}
+	self->last_tip = get_ip_val(p, *end, (*(*p)++ >> PT_PKT_TIP_SHIFT), &self->last_ip2);
+	sample_decoded_detailed("TIP.PGD\t%lx (%d)\n", self->last_tip, count_tnt(self->tnt_cache_state));
+#ifdef DECODER_LOG
+	self->log.tip_pgd++;
+#endif
+}
+
+static inline void tip_fup_handler(decoder_t* self, uint8_t** p, uint8_t** end){
+	if (count_tnt(self->tnt_cache_state)){
+		//trace_disassembler(self->last_tip, self->min_addr, self->max_addr, self->code, self->handler, (self->isr &!self->in_range));
+		trace_disassembler(self->disassembler_state, self->last_tip, (self->isr &!self->in_range), self->tnt_cache_state);
+	}
+	self->last_tip = get_ip_val(p, *end, (*(*p)++ >> PT_PKT_TIP_SHIFT), &self->last_ip2);
+	if(!self->last_tip)
+		sample_decoded_detailed("tip trashed 4\n");
+	sample_decoded_detailed("TIP.FUP\t%lx\n", self->last_tip);
+
+	/* What's next ? */
+	//self->fup_pkt = true;
+#ifdef DECODER_LOG
+	self->log.tip_fup++;
+#endif
+}
+
+static inline void pip_handler(decoder_t* self, uint8_t** p){
+	//if(self->fup_pkt){
+	//	sample_decoded_detailed("CONTEXT SWITCH -> IGNORE\n");
+	//	self->fup_pkt = false;
+	//}
+	(*p) += PT_PKT_PIP_LEN-6;
+	sample_decoded_detailed("PIP\t%llx\n", (get_val(p, 6) >> 1) << 5);
+#ifdef DECODER_LOG
+	self->log.pip++;
+#endif
+}
+
+static inline void psb_handler(decoder_t* self, uint8_t** p){
+#ifdef DEBUG
+	sample_decoded_detailed("PSB\n");
+#endif
+	(*p) += PT_PKT_PSB_LEN;
+#ifdef DECODER_LOG
+	self->log.psbc++;
+#endif
+	pt_decoder_flush(self);
+	//int fd = open("/tmp/psb", O_WRONLY | O_CREAT | O_APPEND, S_IRWXU);
+	//write(fd, "A", 1);
+	//close(fd);
+}
+
+static inline void psbend_handler(decoder_t* self, uint8_t** p){
+#ifdef DEBUG
+	sample_decoded_detailed("PSBEND\n");
+#endif
+	(*p) += PT_PKT_PSBEND_LEN;
+#ifdef DECODER_LOG
+	self->log.psbend++;
+#endif
+}
+
+static inline void long_tnt_handler(decoder_t* self, uint8_t** p){
+	if (self->pge_enabled)
+		append_tnt_cache(self->tnt_cache_state, false, (uint64_t)*p);
+	(*p) += PT_PKT_LTNT_LEN;
+#ifdef DECODER_LOG
+	self->log.tnt64++;
+#endif
+}
+
+static inline void ts_handler(decoder_t* self, uint8_t** p){
+	(*p) += PT_PKT_TS_LEN;
+#ifdef DECODER_LOG
+	self->log.ts++;
+#endif
+}
+
+static inline void ovf_handler(decoder_t* self, uint8_t** p){
+	sample_decoded_detailed("Overflow!\n");
+	(*p) += PT_PKT_OVF_LEN;
+#ifdef DECODER_LOG
+	self->log.ovf++;
+#endif
+}
+
+static inline void mnt_handler(decoder_t* self, uint8_t** p){
+	(*p) += PT_PKT_MNT_LEN;
+#ifdef DECODER_LOG
+	self->log.mnt++;
+#endif
+}
+
+static inline void tma_handler(decoder_t* self, uint8_t** p){
+	(*p) += PT_PKT_TMA_LEN;
+#ifdef DECODER_LOG
+	self->log.tma++;
+#endif
+}
+
+static inline void vmcs_handler(decoder_t* self, uint8_t** p){
+	sample_decoded_detailed("VMCS\n");
+	(*p) += PT_PKT_VMCS_LEN;
+#ifdef DECODER_LOG
+	self->log.vmcs++;
+#endif
+}
+
+void decode_buffer(decoder_t* self, uint8_t* map, size_t len){
+	unsigned char *end = map + len;
+	unsigned char *p;
+	uint8_t byte0;
+
+#ifdef DECODER_LOG
+	flush_log(self);
+#endif
+
+	for (p = map; p < end; ) {
+		p = memmem(p, end - p, psb, PT_PKT_PSB_LEN);
+		if (!p) {
+			p = end;
+			break;
+		}
+		
+		while (p < end) {			
+			byte0 = *p;
+				
+			/* pad */
+			if (byte0 == 0) { 
+				pad_handler(self, &p);
+				continue;
+			}
+			
+			/* tnt8 */
+			if ((byte0 & BIT(0)) == 0 && byte0 != 2){
+				tnt8_handler(self, &p);
+				continue;
+			}
+			
+			/* CYC */
+			if ((byte0 & 3) == 3) {
+				cyc_handler(self, &p);
+				continue;
+			}
+
+			/* CBR */
+			if (*p == PT_PKT_GENERIC_BYTE0 && LEFT(PT_PKT_CBR_LEN) && p[1] == PT_PKT_CBR_BYTE1) {
+				cbr_handler(self, &p);
+				continue;
+			}
+			
+			/* MODE */
+			if (byte0 == PT_PKT_MODE_BYTE0 && LEFT(PT_PKT_MODE_LEN)) {
+				mode_handler(self, &p);
+				continue;
+			}
+
+			switch (byte0 & PT_PKT_TIP_MASK) {
+
+				/* tip */
+				case PT_PKT_TIP_BYTE0:
+					tip_handler(self, &p, &end);
+					continue;
+
+				/* tip.pge */
+				case PT_PKT_TIP_PGE_BYTE0:
+					tip_pge_handler(self, &p, &end);
+					continue;
+
+				/* tip.pgd */
+				case PT_PKT_TIP_PGD_BYTE0:
+					tip_pgd_handler(self, &p, &end);
+					continue;
+
+				/* tip.fup */
+				case PT_PKT_TIP_FUP_BYTE0:
+					tip_fup_handler(self, &p, &end);
+					continue;
+				default:
+					break;
+			}
+
+			if (*p == PT_PKT_GENERIC_BYTE0 && LEFT(PT_PKT_GENERIC_LEN)) {
+
+				/* PIP */
+				if (p[1] == PT_PKT_PIP_BYTE1 && LEFT(PT_PKT_PIP_LEN)) {
+					pip_handler(self, &p);
+					continue;
+				}
+
+				/* PSB */
+				if (p[1] == PT_PKT_PSB_BYTE1 && LEFT(PT_PKT_PSB_LEN) && !memcmp(p, psb, PT_PKT_PSB_LEN)) {
+					psb_handler(self, &p);
+					continue;
+				}
+
+				/* PSBEND */
+				if (p[1] == PT_PKT_PSBEND_BYTE1) {
+					psbend_handler(self, &p);
+					continue;
+				}
+
+				/* long TNT */
+				if (p[1] == PT_PKT_LTNT_BYTE1 && LEFT(PT_PKT_LTNT_LEN)) {
+					long_tnt_handler(self, &p);
+					continue;
+				}
+
+				/* TS */
+				if (p[1] == PT_PKT_TS_BYTE1) {
+					ts_handler(self, &p);
+					continue;
+				}
+
+				/* OVF */
+				if (p[1] == PT_PKT_OVF_BYTE1 && LEFT(PT_PKT_OVF_LEN)) {
+					ovf_handler(self, &p);
+					continue;
+				}
+
+				/* MNT */
+				if (p[1] == PT_PKT_MNT_BYTE1 && LEFT(PT_PKT_MNT_LEN) && p[2] == PT_PKT_MNT_BYTE2) {
+					mnt_handler(self, &p);
+					continue;
+				}
+
+				/* TMA */
+				if (p[1] == PT_PKT_TMA_BYTE1 && LEFT(PT_PKT_TMA_LEN)) {
+					tma_handler(self, &p);
+					continue;
+				}
+
+				/* VMCS */
+				if (p[1] == PT_PKT_VMCS_BYTE1 && LEFT(PT_PKT_VMCS_LEN)) {
+					vmcs_handler(self, &p);
+					continue;
+				}
+			}
+
+			print_unknown(p, end, map);
+			return;
+		}
+	}
+	if(count_tnt(self->tnt_cache_state))
+		sample_decoded_detailed("\tTNT %d (PGE: %d)\n", count_tnt(self->tnt_cache_state), self->pge_enabled);
+}
diff --git a/pt/decoder.h b/pt/decoder.h
new file mode 100644
index 0000000..491ad2e
--- /dev/null
+++ b/pt/decoder.h
@@ -0,0 +1,83 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef DECODER_H
+#define DECODER_H
+
+#include <sys/mman.h>
+#include <sys/fcntl.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <sys/time.h>
+#include <stdbool.h>
+#include "pt/tnt_cache.h"
+#include "pt/disassembler.h"
+#include "pt/logger.h"
+
+//#define DECODER_LOG
+
+typedef struct decoder_s{
+	uint8_t* code;
+	uint64_t min_addr;
+	uint64_t max_addr;
+	void (*handler)(uint64_t);
+	uint64_t last_tip;
+	uint64_t last_ip2;
+	bool fup_pkt;
+	bool isr;
+	bool in_range;
+	bool pge_enabled;
+	disassembler_t* disassembler_state;
+	tnt_cache_t* tnt_cache_state;
+#ifdef DECODER_LOG
+	struct decoder_log_s{
+		uint64_t tnt64;
+		uint64_t tnt8;
+		uint64_t pip;
+		uint64_t cbr;
+		uint64_t ts;
+		uint64_t ovf;
+		uint64_t psbc;
+		uint64_t psbend;
+		uint64_t mnt;
+		uint64_t tma;
+		uint64_t vmcs;
+		uint64_t pad;
+		uint64_t tip;
+		uint64_t tip_pge;
+		uint64_t tip_pgd;
+		uint64_t tip_fup;
+		uint64_t mode;
+	} log;
+#endif
+} decoder_t;
+
+decoder_t* pt_decoder_init(uint8_t* code, uint64_t min_addr, uint64_t max_addr, void (*handler)(uint64_t));
+void decode_buffer(decoder_t* self, uint8_t* map, size_t len);
+void pt_decoder_destroy(decoder_t* self);
+void pt_decoder_flush(decoder_t* self);
+
+#endif
\ No newline at end of file
diff --git a/pt/disassembler.c b/pt/disassembler.c
new file mode 100644
index 0000000..0358c10
--- /dev/null
+++ b/pt/disassembler.c
@@ -0,0 +1,461 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "pt/disassembler.h"
+
+#define LOOKUP_TABLES		5
+#define IGN_MOD_RM			0
+#define IGN_OPODE_PREFIX	0
+#define MODRM_REG(x)		(x << 3)
+#define MODRM_AND			0b00111000
+
+/* http://stackoverflow.com/questions/29600668/what-meaning-if-any-does-the-mod-r-m-byte-carry-for-the-unconditional-jump-ins */
+/* conditional branch */
+cofi_ins cb_lookup[] = {
+	{X86_INS_JAE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JA,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JBE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JB,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JCXZ,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JECXZ,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JGE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JG,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JLE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JL,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JNE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JNO,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JNP,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JNS,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JO,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JP,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JRCXZ,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+    {X86_INS_JS,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_LOOP,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_LOOPE,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_LOOPNE,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+};
+
+/* unconditional direct branch */
+cofi_ins udb_lookup[] = {
+	{X86_INS_JMP,		IGN_MOD_RM,	0xe9},
+	{X86_INS_JMP,		IGN_MOD_RM, 0xeb},
+	{X86_INS_CALL,		IGN_MOD_RM,	0xe8},	
+};
+
+/* indirect branch */
+cofi_ins ib_lookup[] = {
+	{X86_INS_JMP,		MODRM_REG(4),	0xff},
+	{X86_INS_CALL,		MODRM_REG(2),	0xff},	
+};
+
+/* near ret */
+cofi_ins nr_lookup[] = {
+	{X86_INS_RET,		IGN_MOD_RM,	0xc3},
+	{X86_INS_RET,		IGN_MOD_RM,	0xc2},
+};
+ 
+/* far transfers */ 
+cofi_ins ft_lookup[] = {
+	{X86_INS_INT3,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_INT,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_INT1,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_INTO,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_IRET,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_IRETD,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_IRETQ,		IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_JMP,		IGN_MOD_RM,		0xea},
+	{X86_INS_JMP,		MODRM_REG(5),	0xff},
+	{X86_INS_CALL,		IGN_MOD_RM,		0x9a},
+	{X86_INS_CALL,		MODRM_REG(3),	0xff},
+	{X86_INS_RET,		IGN_MOD_RM,		0xcb},
+	{X86_INS_RET,		IGN_MOD_RM,		0xca},
+	{X86_INS_SYSCALL,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_SYSENTER,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_SYSEXIT,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_SYSRET,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_VMLAUNCH,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+	{X86_INS_VMRESUME,	IGN_MOD_RM,	IGN_OPODE_PREFIX},
+};
+
+uint16_t cmp_lookup[] = {
+	X86_INS_CMP,
+	X86_INS_CMPPD,
+	X86_INS_CMPPS,
+	X86_INS_CMPSB,
+	X86_INS_CMPSD,
+	X86_INS_CMPSQ,
+	X86_INS_CMPSS,
+	X86_INS_CMPSW,
+	X86_INS_CMPXCHG16B,
+	X86_INS_CMPXCHG,
+	X86_INS_CMPXCHG8B,
+};
+
+
+cofi_ins* lookup_tables[] = {
+	cb_lookup,
+	udb_lookup,
+	ib_lookup,
+	nr_lookup,
+	ft_lookup,
+};
+
+uint8_t lookup_table_sizes[] = {
+	22,
+	3,
+	2,
+	2,
+	19
+};
+
+/* ===== kAFL disassembler cofi list ===== */
+
+static cofi_list* create_list_head(void){
+	cofi_list* head = malloc(sizeof(cofi_list));
+	if (head != NULL){
+		head->list_ptr = NULL;
+		head->cofi_ptr = NULL;
+		head->cofi = NULL;
+		return head;
+	}
+	return NULL;
+}
+
+static void free_list(cofi_list* head){
+	cofi_list *tmp1, *tmp2;
+	tmp1 = head;
+	while (1){
+		tmp2 = tmp1;
+		if(tmp1 == NULL){
+			break;
+		}
+		tmp1 = tmp1->list_ptr;
+		if (tmp2->cofi != NULL){
+			free(tmp2->cofi);
+		}
+		free(tmp2);
+	}
+}
+
+static cofi_list* new_list_element(cofi_list* predecessor, cofi_header* cofi){
+	if(predecessor){
+		cofi_list* next = malloc(sizeof(cofi_list));
+		if (next){
+			predecessor->list_ptr = next;
+			next->list_ptr = NULL;
+			next->cofi_ptr = NULL;
+			next->cofi = cofi;
+			return next;
+		}
+	}
+	return NULL;
+}
+
+static void edit_cofi_ptr(cofi_list* element, cofi_list* target){
+	if (element){
+		element->cofi_ptr = target;
+	}
+}
+
+/* ===== kAFL disassembler hashmap ===== */
+
+static void map_put(disassembler_t* self, uint64_t addr, uint64_t ref){
+	int ret;
+	khiter_t k;
+	k = kh_put(ADDR0, self->map, addr, &ret); 
+	kh_value(self->map, k) = ref;
+}
+
+static int map_exist(disassembler_t* self, uint64_t addr){
+	khiter_t k;
+	k = kh_get(ADDR0, self->map, addr); 
+	if(k != kh_end(self->map)){
+		return 1;
+	}
+	return 0;
+}
+
+static int map_get(disassembler_t* self, uint64_t addr, uint64_t* ref){
+	khiter_t k;
+	k = kh_get(ADDR0, self->map, addr); 
+	if(k != kh_end(self->map)){
+		*ref = kh_value(self->map, k); 
+		return 0;
+	} 
+	return 1;
+}
+
+/* ===== kAFL disassembler engine ===== */
+
+static inline uint64_t fast_strtoull(const char *hexstring){
+	uint64_t result = 0;
+	uint8_t i = 0;
+	if (hexstring[1] == 'x' || hexstring[1] == 'X')
+		i = 2;
+	for (; hexstring[i]; i++)
+		result = (result << 4) + (9 * (hexstring[i] >> 6) + (hexstring[i] & 017));
+	return result;
+}
+
+static inline uint64_t hex_to_bin(char* str){
+	//return (uint64_t)strtoull(str, NULL, 16);
+	return fast_strtoull(str);
+}
+
+static cofi_type opcode_analyzer(disassembler_t* self, cs_insn *ins){
+	uint8_t i, j;
+	cs_x86 details = ins->detail->x86;
+	
+	for (i = 0; i < LOOKUP_TABLES; i++){
+		for (j = 0; j < lookup_table_sizes[i]; j++){
+			if (ins->id == lookup_tables[i][j].opcode){
+				
+				/* check MOD R/M */
+				if (lookup_tables[i][j].modrm != IGN_MOD_RM && lookup_tables[i][j].modrm != (details.modrm & MODRM_AND))
+						continue;	
+						
+				/* check opcode prefix byte */
+				if (lookup_tables[i][j].opcode_prefix != IGN_OPODE_PREFIX && lookup_tables[i][j].opcode_prefix != details.opcode[0])
+						continue;
+#ifdef DEBUG
+				/* found */
+				printf("%lx (%d)\t%s\t%s\t\t", ins->address, i, ins->mnemonic, ins->op_str);
+				print_string_hex("      \t", ins->bytes, ins->size);
+#endif
+				return i;
+				
+			}
+		}
+	}
+	return NO_COFI_TYPE;
+}
+
+static cofi_list* analyse_assembly(disassembler_t* self, uint64_t base_address){
+	csh handle;
+	cs_insn *insn;
+	cofi_type type;
+	cofi_header* tmp = NULL;
+	uint64_t tmp_list_element = 0;
+	bool last_nop = false;
+	uint64_t total = 0;
+	uint64_t cofi = 0;
+	const uint8_t* code = self->code + (base_address-self->min_addr);
+	size_t code_size = (self->max_addr-base_address);
+	uint64_t address = base_address;
+	cofi_list* predecessor = NULL;
+	cofi_list* first = NULL;
+				
+	if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
+		return false;
+	
+	cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);
+	insn = cs_malloc(handle);
+	
+	while(cs_disasm_iter(handle, &code, &code_size, &address, insn)) {	
+		if (insn->address > self->max_addr){
+			break;
+		}
+			
+		type = opcode_analyzer(self, insn);
+		total++;
+		
+		if (self->debug){
+			printf("%lx:\t(%d)\t%s\t%s\t\t\n", insn->address, type, insn->mnemonic, insn->op_str);
+		}
+		
+		if (!last_nop){
+			tmp = malloc(sizeof(cofi_header));
+			tmp->type = NO_COFI_TYPE;
+			tmp->ins_addr = 0;
+			tmp->target_addr = 0;
+	
+			edit_cofi_ptr(predecessor, self->list_element);
+			predecessor = self->list_element;
+			self->list_element = new_list_element(self->list_element, tmp);
+		}
+		
+		if (map_exist(self, insn->address)){
+			if(tmp){
+				map_get(self, insn->address, &tmp_list_element);
+				edit_cofi_ptr(self->list_element, (cofi_list*)tmp_list_element);
+				//printf("EDIT COFI PTR (%p %p %p %d)\n", list_element, (cofi_list*)tmp_list_element, list_element->cofi, list_element->cofi->type);
+			}
+			break;
+		}
+		
+		if (type != NO_COFI_TYPE){
+			cofi++;
+			last_nop = false;
+			tmp->type = type;
+			tmp->ins_addr = insn->address;
+			if (type == COFI_TYPE_CONDITIONAL_BRANCH || type == COFI_TYPE_UNCONDITIONAL_DIRECT_BRANCH){
+				tmp->target_addr = hex_to_bin(insn->op_str);	
+			} else {
+				tmp->target_addr = 0;
+			}
+			self->list_element->cofi = tmp;
+			map_put(self, tmp->ins_addr, (uint64_t)(self->list_element));
+		} else {
+			last_nop = true;
+			map_put(self, insn->address, (uint64_t)(self->list_element));
+		}
+		
+		if (!first){
+			first = self->list_element;
+		}
+	}
+	
+	cs_free(insn, 1);
+	cs_close(&handle);
+	return first;
+}
+
+disassembler_t* init_disassembler(uint8_t* code, uint64_t min_addr, uint64_t max_addr, void (*handler)(uint64_t)){
+	disassembler_t* res = malloc(sizeof(disassembler_t));
+	res->code = code;
+	res->min_addr = min_addr;
+	res->max_addr = max_addr;
+	res->handler = handler;
+	res->debug = false;
+	res->map = kh_init(ADDR0);
+	res->list_head = create_list_head();
+	res->list_element = res->list_head;
+	return res;
+}
+
+void destroy_disassembler(disassembler_t* self){
+	kh_destroy(ADDR0, self->map);
+	free_list(self->list_head);
+	free(self);
+}
+
+static inline bool out_of_bounds(disassembler_t* self, uint64_t addr){
+	return ((addr < self->min_addr) | (addr > self->max_addr));
+}
+
+static inline cofi_list* get_obj(disassembler_t* self, uint64_t entry_point, tnt_cache_t* tnt_cache_state){
+	uint64_t tmp_list_element;
+	if (!count_tnt(tnt_cache_state))
+		return NULL;
+	if (out_of_bounds(self, entry_point)){
+		return NULL;
+	}
+	
+	if(map_get(self, entry_point, &tmp_list_element)){
+		return analyse_assembly(self, entry_point);
+	}
+	return (cofi_list*)tmp_list_element;
+}
+
+
+bool trace_disassembler(disassembler_t* self, uint64_t entry_point, bool isr, tnt_cache_t* tnt_cache_state){
+	cofi_list *obj, *last_obj;
+	uint8_t tnt;
+	// int fd = 0; 
+	int last_type = -1;
+		
+	obj = get_obj(self, entry_point, tnt_cache_state);
+	while(true){		
+		
+		if(!obj){
+			if (last_type == COFI_TYPE_FAR_TRANSFERS)
+				return true;
+			return false;
+		}
+		
+		switch(obj->cofi->type){
+
+			case COFI_TYPE_CONDITIONAL_BRANCH:
+				last_type = COFI_TYPE_CONDITIONAL_BRANCH;
+				tnt = process_tnt_cache(tnt_cache_state);
+				switch(tnt){
+					case TNT_EMPTY:
+						return false;
+					case TAKEN:
+						sample_decoded_detailed("(%d)\t%lx\t(Taken)\n", COFI_TYPE_CONDITIONAL_BRANCH, obj->cofi->ins_addr);
+						self->handler(obj->cofi->ins_addr);
+						if (out_of_bounds(self, obj->cofi->ins_addr))
+							return true;
+						obj = get_obj(self, obj->cofi->target_addr, tnt_cache_state);
+						break;
+					case NOT_TAKEN:
+						sample_decoded_detailed("(%d)\t%lx\t(Not Taken)\n", COFI_TYPE_CONDITIONAL_BRANCH ,obj->cofi->ins_addr);
+						self->handler(obj->cofi->ins_addr);
+						//if(!count_tnt())
+						//	return true;
+						obj = obj->cofi_ptr;
+						break;
+				}
+				break;
+
+			case COFI_TYPE_UNCONDITIONAL_DIRECT_BRANCH:
+				last_type = COFI_TYPE_UNCONDITIONAL_DIRECT_BRANCH;
+				sample_decoded_detailed("(%d)\t%lx\n", COFI_TYPE_UNCONDITIONAL_DIRECT_BRANCH ,obj->cofi->ins_addr);
+				last_obj = obj;
+				if (out_of_bounds(self, obj->cofi->target_addr)){
+					if (!count_tnt(tnt_cache_state)){
+						return false;
+					}
+					obj = obj->cofi_ptr;
+				}
+				else {
+					obj = get_obj(self, obj->cofi->target_addr, tnt_cache_state);
+				}
+				/* loop */
+				if(obj && (last_obj->cofi->ins_addr == obj->cofi->ins_addr)){
+					return false;
+				}
+				break;
+
+			case COFI_TYPE_INDIRECT_BRANCH:
+				last_type = COFI_TYPE_INDIRECT_BRANCH;
+				self->handler(obj->cofi->target_addr);
+				sample_decoded_detailed("(2)\t%lx\n",obj->cofi->ins_addr);
+				return false;
+				obj = obj->cofi_ptr;
+				break;
+
+			case COFI_TYPE_NEAR_RET:
+				last_type = COFI_TYPE_NEAR_RET;
+				sample_decoded_detailed("(3)\t%lx\n",obj->cofi->ins_addr);
+				return false;
+				obj = obj->cofi_ptr;
+				break;
+
+			case COFI_TYPE_FAR_TRANSFERS:
+				last_type = COFI_TYPE_FAR_TRANSFERS;
+				sample_decoded_detailed("(4)\t%lx\n",obj->cofi->ins_addr);
+				return true;
+				obj = obj->cofi_ptr;
+				break;
+
+			case NO_COFI_TYPE:
+				last_type = NO_COFI_TYPE;
+				sample_decoded_detailed("(5)\t%lx\n",obj->cofi->ins_addr);
+				#ifdef DEBUG 
+				#endif
+				obj = obj->cofi_ptr;
+				break;
+		}
+	}
+}
+
diff --git a/pt/disassembler.h b/pt/disassembler.h
new file mode 100644
index 0000000..fecfb79
--- /dev/null
+++ b/pt/disassembler.h
@@ -0,0 +1,86 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef DISASSEMBLER_H
+#define DISASSEMBLER_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <inttypes.h>
+#include <capstone/capstone.h>
+#include <capstone/x86.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "qemu/osdep.h"
+#include "pt/khash.h"
+#include "pt/tnt_cache.h"
+#include "pt/logger.h"
+
+KHASH_MAP_INIT_INT(ADDR0, uint64_t)
+
+typedef struct{
+	uint16_t opcode;
+	uint8_t modrm;
+	uint8_t opcode_prefix;
+} cofi_ins;
+
+typedef enum cofi_types{
+	COFI_TYPE_CONDITIONAL_BRANCH, 
+	COFI_TYPE_UNCONDITIONAL_DIRECT_BRANCH, 
+	COFI_TYPE_INDIRECT_BRANCH, 
+	COFI_TYPE_NEAR_RET, 
+	COFI_TYPE_FAR_TRANSFERS,
+	NO_COFI_TYPE
+} cofi_type;
+
+
+typedef struct {
+	uint64_t ins_addr;
+	uint64_t target_addr;
+	cofi_type type;
+} cofi_header;
+
+typedef struct cofi_list {
+	struct cofi_list *list_ptr;
+	struct cofi_list *cofi_ptr;
+	cofi_header *cofi;
+} cofi_list;
+
+typedef struct disassembler_s{
+	uint8_t* code;
+	uint64_t min_addr;
+	uint64_t max_addr;
+	void (*handler)(uint64_t);
+	khash_t(ADDR0) *map;
+	cofi_list* list_head;
+	cofi_list* list_element;
+	bool debug;
+} disassembler_t;
+
+disassembler_t* init_disassembler(uint8_t* code, uint64_t min_addr, uint64_t max_addr, void (*handler)(uint64_t));
+bool trace_disassembler(disassembler_t* self, uint64_t entry_point, bool isr, tnt_cache_t* tnt_cache_state);
+void destroy_disassembler(disassembler_t* self);
+
+#endif
\ No newline at end of file
diff --git a/pt/filter.c b/pt/filter.c
new file mode 100644
index 0000000..ef25aa5
--- /dev/null
+++ b/pt/filter.c
@@ -0,0 +1,121 @@
+/*
+
+Copyright (C) 2017 Cornelius Aschermann
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "filter.h"
+#include <fcntl.h>
+
+/* http://zimbry.blogspot.ch/2011/09/better-bit-mixing-improving-on.html */
+static inline uint64_t mix_bits(uint64_t v) {
+  v ^= (v >> 31);
+  v *= 0x7fb5d329728ea185;
+  v ^= (v >> 27);
+  v *= 0x81dadef4bc2dd44d;
+  v ^= (v >> 33);
+  return v;
+}
+
+static inline uint64_t mix_tuple(uint64_t curent_addr, uint64_t prev_addr){
+  return mix_bits((curent_addr<<32) + (prev_addr&0xFFFFFFFF));
+}
+
+static bool filter_get_bitmap(filter_t* self, uint8_t* bitmap, uint64_t offset){
+  assert(offset <= self->size);
+  return (bitmap[offset/8] & (1<< offset%8));
+}
+
+static void filter_set_bitmap(filter_t* self, uint8_t* bitmap, uint64_t offset){
+  assert(offset <= self->size);
+  bitmap[offset/8] |= (1<< offset%8);
+}
+
+static bool filter_get_bitmap_sync(filter_t* self, uint8_t* bitmap, uint64_t offset){
+  assert(offset <= self->size);
+  return bitmap[offset];
+}
+
+static void filter_set_bitmap_sync(filter_t* self, uint8_t* bitmap, uint64_t offset){
+  assert(offset <= self->size);
+  if(!bitmap[offset]){
+    bitmap[offset] = 1;  
+    self->blacklist_count++;
+  }
+}
+
+/* default: 128MB */
+filter_t* new_filter(uint64_t from, uint64_t to, uint8_t *filter_bitmap){
+  filter_t* res = malloc(sizeof(filter_t));
+  assert(from < to);
+  res->size = to-from;
+  res->execs = 0;
+  res->counters = malloc(res->size*2);
+  res->from_addr = from;
+  res->to_addr = to;
+  res->hit_bitmap = malloc(res->size/8);
+  res->filter_bitmap = filter_bitmap;
+  res->prev_addr = 0x0;
+  res->blacklist_count = 0;
+  return res;
+}
+
+void filter_init_determinism_run(filter_t* self){
+  self->execs = 0;
+  memset(self->counters, 0, self->size*2);
+}
+
+void filter_init_new_exec(filter_t* self){
+  memset(self->hit_bitmap, 0, self->size/8);
+}
+
+void filter_add_address(filter_t* self, uint64_t addr){
+  if(self->from_addr <= addr && addr <= self->to_addr){
+    filter_set_bitmap(self,self->hit_bitmap,addr-self->from_addr);
+  }
+}
+
+void filter_finalize_exec(filter_t* self){
+  self->execs ++;
+  for(uint64_t a = self->from_addr; a < self->to_addr; a++){
+    if(filter_get_bitmap(self, self->hit_bitmap,a - self->from_addr)){
+      self->counters[a - self->from_addr] += 1;
+    }
+  }
+}
+
+
+void filter_finalize_determinism_run(filter_t* self){
+  for(uint64_t a = self->from_addr; a < self->to_addr; a++){
+    uint64_t o = a-self->from_addr;
+    if(self->counters[o] != self->execs && self->counters[o]){
+      filter_set_bitmap_sync(self, self->filter_bitmap, o);
+    }
+  }
+}
+
+bool filter_is_address_nondeterministic(filter_t* self, uint64_t addr){
+  if(self->from_addr <= addr && addr <= self->to_addr){
+    return filter_get_bitmap_sync(self, self->filter_bitmap,addr-self->from_addr);
+  }
+  return false;
+}
+
+uint32_t filter_count_new_addresses(filter_t* self){
+  return self->blacklist_count;
+}
diff --git a/pt/filter.h b/pt/filter.h
new file mode 100644
index 0000000..63dd490
--- /dev/null
+++ b/pt/filter.h
@@ -0,0 +1,62 @@
+/*
+
+Copyright (C) 2017 Cornelius Aschermann
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef __FILTER__
+#define __FILTER__
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <assert.h>
+
+typedef struct filter_s {
+  size_t size;
+  uint16_t execs;
+  uint16_t *counters;
+  uint8_t *hit_bitmap;
+  uint8_t *filter_bitmap;
+  uint64_t prev_addr;
+  uint64_t from_addr;
+  uint64_t to_addr;
+  uint32_t blacklist_count;
+} filter_t;
+
+
+
+filter_t* new_filter(uint64_t from, uint64_t to, uint8_t *filter_bitmap);
+
+void filter_init_determinism_run(filter_t* self);
+
+void filter_init_new_exec(filter_t* self);
+
+void filter_add_address(filter_t* self, uint64_t addr);
+
+void filter_finalize_exec(filter_t* self);
+
+void filter_finalize_determinism_run(filter_t* self);
+
+bool filter_is_address_nondeterministic(filter_t* self, uint64_t addr);
+
+uint32_t filter_count_new_addresses(filter_t* self);
+
+#endif
diff --git a/pt/hypercall.c b/pt/hypercall.c
new file mode 100644
index 0000000..c96541e
--- /dev/null
+++ b/pt/hypercall.c
@@ -0,0 +1,359 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "qemu/osdep.h"
+#include <linux/kvm.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include "exec/memory.h"
+#include "sysemu/kvm_int.h"
+#include "sysemu/kvm.h"
+#include "sysemu/runstate.h"
+#include "pt.h"
+#include "pt/hypercall.h"
+#include "pt/filter.h"
+#include "pt/memory_access.h"
+#include "pt/interface.h"
+
+bool hypercall_enabled = false;
+void* payload_buffer = NULL;
+void* payload_buffer_guest = NULL;
+void* program_buffer = NULL;
+char info_buffer[INFO_SIZE];
+void* argv = NULL;
+
+static bool mutex_init = false;
+static bool mutex_locked = false;
+static bool init_state = true;
+pthread_mutex_t lock;
+
+void (*handler)(char, void*) = NULL; 
+void* s = NULL;
+
+uint64_t filter[INTEL_PT_MAX_RANGES][2];
+bool filter_enabled[INTEL_PT_MAX_RANGES] = {false, false, false, false};
+/* vertex filter */
+filter_t *det_filter[INTEL_PT_MAX_RANGES] = {NULL, NULL, NULL, NULL};
+/* edge filter */
+filter_t *det_tfilter = NULL;
+bool det_filter_enabled[INTEL_PT_MAX_RANGES] = {false, false, false, false};
+
+static void hypercall_lock(void);
+static bool hypercall_snd_char(char val);
+
+bool pt_hypercalls_enabled(void){
+	return hypercall_enabled;
+}
+
+void pt_setup_enable_hypercalls(void){
+	hypercall_enabled = true;
+}
+
+void pt_setup_snd_handler(void (*tmp)(char, void*), void* tmp_s){
+	s = tmp_s;
+	handler = tmp;
+}
+
+static bool hypercall_snd_char(char val){
+	if (handler != NULL){
+		handler(val, s);
+		return true;
+	}
+	return false;
+}
+
+void pt_setup_ip_filters(uint8_t filter_id, uint64_t start, uint64_t end, void* filter_bitmap, void* tfilter_bitmap){
+	if (filter_id < INTEL_PT_MAX_RANGES){
+		filter_enabled[filter_id] = true;
+		filter[filter_id][0] = start;
+		filter[filter_id][1] = end;
+		if (filter_bitmap){
+			det_filter[filter_id] = new_filter(start, end, filter_bitmap);
+			//printf("det_filter enabled\n");
+			if(!det_tfilter){
+				det_tfilter = new_filter(0, DEFAULT_EDGE_FILTER_SIZE, tfilter_bitmap);
+				//printf("det_tfilter enabled\n");
+			}
+		}
+	}
+}
+
+static inline void init_det_filter(void){
+	int i;
+	for(i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if (det_filter_enabled[i]){
+			filter_init_new_exec(det_filter[i]);
+			filter_init_new_exec(det_tfilter);
+		}	
+	}
+}
+
+static inline void fin_det_filter(void){
+	//printf("%s \n", __func__);
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if (det_filter_enabled[i]){
+			filter_finalize_exec(det_filter[i]);
+			filter_finalize_exec(det_tfilter);
+		}
+	}
+}
+
+void hypercall_submit_address(uint64_t address){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_filter[i] && det_filter_enabled[i]){
+			//printf("%s %lx \n", __func__, address);
+			filter_add_address(det_filter[i], address);
+		}
+	}
+}
+
+void hypercall_submit_transition(uint32_t value){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_tfilter && det_filter_enabled[i]){
+			//printf("%s %lx \n", __func__, value);
+			filter_add_address(det_tfilter, value);
+		}
+	}
+}
+
+bool hypercall_check_tuple(uint64_t current_addr, uint64_t prev_addr){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_filter[i]){
+			if(filter_is_address_nondeterministic(det_filter[i], current_addr) ||  filter_is_address_nondeterministic(det_filter[i], prev_addr)){
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+bool hypercall_check_transition(uint64_t value){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_tfilter){
+			if(filter_is_address_nondeterministic(det_tfilter, value)){
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+void hypercall_check_in_range(uint64_t* addr){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if (*addr < filter[i][0]){
+			*addr = filter[i][0];
+			return;
+		}
+
+		if (*addr > filter[i][1]){
+			*addr = filter[i][1];
+			return;
+		}
+	}
+}
+
+void hypercall_enable_filter(void){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_filter[i] && !det_filter_enabled[i]){
+			//printf("%s (%d)\n", __func__, i);
+			det_filter_enabled[i] = true;
+			filter_init_determinism_run(det_filter[i]);
+			filter_init_determinism_run(det_tfilter);
+		}
+	}
+}
+
+void hypercall_disable_filter(void){
+	for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(det_filter[i] && det_filter_enabled[i]){
+			//printf("%s (%d)\n", __func__, i);
+			filter_finalize_determinism_run(det_filter[i]);
+			if(!filter_count_new_addresses(det_filter[i])){
+				filter_finalize_determinism_run(det_tfilter);
+			}
+			det_filter_enabled[i] = false;
+		}
+	}
+}
+
+void hypercall_commit_filter(void){
+	fin_det_filter();
+}
+
+void hypercall_unlock(void){
+	if (mutex_locked){
+		mutex_locked = false;
+		pthread_mutex_unlock(&lock);
+	}
+}
+
+void hypercall_reload(void){
+	CPUState *cpu = qemu_get_cpu(0);
+	cpu->reload_pending = true;
+	hypercall_unlock();
+	//cpu_synchronize_state(cpu);
+	kvm_cpu_synchronize_state(cpu);
+	init_state = true;
+}
+
+/* ToDO: Mutual exclusion */
+static void hypercall_lock(void){
+	if(!mutex_init){
+		//pthread_mutex_init(&lock, NULL);
+		pthread_mutex_lock(&lock);
+		mutex_init = true;
+	}
+	if(!mutex_locked){
+		mutex_locked = true;
+		hypercall_snd_char(KAFL_PROTO_ACQUIRE);
+		pthread_mutex_lock(&lock);
+	}
+}
+
+void pt_setup_program(void* ptr){
+	program_buffer = ptr;
+}
+
+void pt_setup_payload(void* ptr){
+	payload_buffer = ptr;
+}
+
+void pt_disable_wrapper(CPUState *cpu){
+	int ret = pt_disable(cpu, false);
+	//fin_det_filter();
+	if (ret > 0){
+		pt_dump(cpu, ret);
+		cpu->pt_enabled = false;
+	}
+}
+
+void handle_hypercall_kafl_next_payload(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		if (init_state){
+			hypercall_lock();
+		} else {
+			hypercall_lock();
+			write_virtual_memory((uint64_t)payload_buffer_guest, payload_buffer, PAYLOAD_SIZE, cpu);
+		}
+	}
+}
+
+void handle_hypercall_kafl_acquire(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		if (!init_state){
+			init_det_filter();
+			if (pt_enable(cpu, false) == 0){
+				cpu->pt_enabled = true;
+			}
+		}
+	}
+}
+
+void handle_hypercall_get_payload(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		if(payload_buffer){
+			payload_buffer_guest = (void*)run->hypercall.args[0];
+			write_virtual_memory((uint64_t)payload_buffer_guest, payload_buffer, PAYLOAD_SIZE, cpu);
+		}
+	}
+}
+
+void handle_hypercall_get_program(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		if(program_buffer){
+			printf("Program: %lx\n", (uint64_t)run->hypercall.args[0]);
+			write_virtual_memory((uint64_t)run->hypercall.args[0], program_buffer, PROGRAM_SIZE, cpu);
+			//printf("Done!\n");
+		}
+	}
+}
+
+void handle_hypercall_kafl_release(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		if (init_state){
+			init_state = false;	
+			for(int i = 0; i < INTEL_PT_MAX_RANGES; i++){
+				if(filter_enabled[i]){
+					pt_enable_ip_filtering(cpu, i, filter[i][0], filter[i][1], false);
+				}
+			}
+			hypercall_snd_char(KAFL_PROTO_RELEASE);
+		} else {
+			pt_disable_wrapper(cpu);
+		}
+	}
+}
+
+void handle_hypercall_kafl_cr3(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		printf("CR3: %lx\n", (uint64_t)run->hypercall.args[0]);
+		pt_set_cr3(cpu, run->hypercall.args[0], false);
+	}
+}
+
+void handle_hypercall_kafl_submit_panic(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		printf("PANIC: %lx\n", (uint64_t)run->hypercall.args[0]);
+		write_virtual_memory((uint64_t)run->hypercall.args[0], (uint8_t*)PANIC_PAYLOAD, PAYLOAD_BUFFER_SIZE, cpu);
+	}
+}
+
+void handle_hypercall_kafl_submit_kasan(struct kvm_run *run, CPUState *cpu){
+	if(hypercall_enabled){
+		printf("KASAN: %lx\n", (uint64_t)run->hypercall.args[0]);
+		write_virtual_memory((uint64_t)run->hypercall.args[0], (uint8_t*)KASAN_PAYLOAD, PAYLOAD_BUFFER_SIZE, cpu);
+	}
+}
+
+void handle_hypercall_kafl_panic(struct kvm_run *run, CPUState *cpu){
+	printf("PANIC!\n");
+	if(hypercall_enabled){
+		pt_disable_wrapper(cpu);
+		hypercall_snd_char(KAFL_PROTO_CRASH);
+		//hypercall_reload();
+	}
+}
+
+void handle_hypercall_kafl_kasan(struct kvm_run *run, CPUState *cpu){
+	printf("KASAN!\n");
+	if(hypercall_enabled){
+		pt_disable_wrapper(cpu);
+		hypercall_snd_char(KAFL_PROTO_KASAN);
+		//hypercall_reload();
+	}
+}
+
+void handle_hypercall_kafl_lock(struct kvm_run *run, CPUState *cpu){
+	printf("kAFL: VM PAUSED - CREATE SNAPSHOT NOW!\n");
+	vm_stop(RUN_STATE_PAUSED);
+}
+
+void handle_hypercall_kafl_info(struct kvm_run *run, CPUState *cpu){
+	read_virtual_memory((uint64_t)run->hypercall.args[0], (uint8_t*)info_buffer, INFO_SIZE, cpu);
+	FILE* info_file_fd = fopen(INFO_FILE, "w");
+	fprintf(info_file_fd, "%s\n", info_buffer);
+	fclose(info_file_fd);
+	if(hypercall_enabled){
+		hypercall_snd_char(KAFL_PROTO_INFO);
+	}
+	qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_QMP_QUIT);
+}
diff --git a/pt/hypercall.h b/pt/hypercall.h
new file mode 100644
index 0000000..92699e0
--- /dev/null
+++ b/pt/hypercall.h
@@ -0,0 +1,92 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef HYPERCALL_H
+#define HYPERCALL_H
+
+#define KAFL_NEXT_PAYLOAD
+
+#define PAYLOAD_BUFFER_SIZE		26
+
+/*
+ * Panic Notifier Payload (x86-64)
+ * fa                      cli
+ * 48 c7 c0 1f 00 00 00    mov    rax,0x1f
+ * 48 c7 c3 08 00 00 00    mov    rbx,0x8
+ * 48 c7 c1 00 00 00 00    mov    rcx,0x0
+ * 0f 01 c1                vmcall
+ * f4                      hlt
+ */
+#define PANIC_PAYLOAD "\xFA\x48\xC7\xC0\x1F\x00\x00\x00\x48\xC7\xC3\x08\x00\x00\x00\x48\xC7\xC1\x00\x00\x00\x00\x0F\x01\xC1\xF4"
+
+/*
+ * KASAN Notifier Payload (x86-64)
+ * fa                      cli
+ * 48 c7 c0 1f 00 00 00    mov    rax,0x1f
+ * 48 c7 c3 08 00 00 00    mov    rbx,0x9
+ * 48 c7 c1 00 00 00 00    mov    rcx,0x0
+ * 0f 01 c1                vmcall
+ * f4                      hlt
+ */
+#define KASAN_PAYLOAD "\xFA\x48\xC7\xC0\x1F\x00\x00\x00\x48\xC7\xC3\x09\x00\x00\x00\x48\xC7\xC1\x00\x00\x00\x00\x0F\x01\xC1\xF4"
+
+void pt_setup_program(void* ptr);
+void pt_setup_payload(void* ptr);
+void pt_setup_snd_handler(void (*tmp)(char, void*), void* tmp_s);
+void pt_setup_ip_filters(uint8_t filter_id, uint64_t start, uint64_t end, void* filter_bitmap, void* tfilter_bitmap);
+void pt_setup_enable_hypercalls(void);
+
+void pt_disable_wrapper(CPUState *cpu);
+
+void hypercall_submit_address(uint64_t address);
+bool hypercall_check_tuple(uint64_t current_addr, uint64_t prev_addr);
+void hypercall_check_in_range(uint64_t* addr);
+
+
+bool hypercall_check_transition(uint64_t value);
+void hypercall_submit_transition(uint32_t value);
+
+void hypercall_enable_filter(void);
+void hypercall_disable_filter(void);
+void hypercall_commit_filter(void);
+
+bool pt_hypercalls_enabled(void);
+
+void hypercall_unlock(void);
+void hypercall_reload(void);
+
+void handle_hypercall_kafl_acquire(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_get_payload(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_get_program(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_release(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_cr3(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_submit_panic(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_submit_kasan(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_panic(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_kasan(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_lock(struct kvm_run *run, CPUState *cpu);
+void handle_hypercall_kafl_info(struct kvm_run *run, CPUState *cpu);
+
+#ifdef KAFL_NEXT_PAYLOAD
+void handle_hypercall_kafl_next_payload(struct kvm_run *run, CPUState *cpu);
+#endif
+
+#endif
\ No newline at end of file
diff --git a/pt/interface.c b/pt/interface.c
new file mode 100644
index 0000000..9f51d65
--- /dev/null
+++ b/pt/interface.c
@@ -0,0 +1,281 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu/cutils.h"
+#include "chardev/char-fe.h"
+#include "hw/hw.h"
+#include "hw/i386/pc.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/msi.h"
+#include "hw/pci/msix.h"
+#include "hw/qdev-properties-system.h"
+#include "sysemu/kvm.h"
+#include "migration/migration.h"
+#include "qemu/error-report.h"
+#include "qemu/event_notifier.h"
+#include "qom/object_interfaces.h"
+#include "sysemu/hostmem.h"
+#include "sysemu/qtest.h"
+#include "qapi/visitor.h"
+#include "exec/ram_addr.h"
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "pt/pt.h"
+#include "pt/hypercall.h"
+#include "pt/filter.h"
+#include "pt/interface.h"
+#include <time.h>
+
+#define CONVERT_UINT64(x) (uint64_t)(strtoull(x, NULL, 16))
+
+#define TYPE_KAFLMEM "kafl"
+#define KAFLMEM(obj) \
+		OBJECT_CHECK(kafl_mem_state, (obj), TYPE_KAFLMEM)
+
+uint32_t kafl_bitmap_size = DEFAULT_KAFL_BITMAP_SIZE;
+
+static void pci_kafl_guest_realize(PCIDevice *dev, Error **errp);
+
+typedef struct kafl_mem_state {
+	PCIDevice parent_obj;
+
+	Chardev *kafl_chr_drv_state;
+	CharBackend chr;
+	
+	char* data_bar_fd_0;
+	char* data_bar_fd_1;
+	char* data_bar_fd_2;
+	char* bitmap_file;
+
+	char* filter_bitmap[4];
+	char* ip_filter[4][2];
+
+	bool irq_filter;
+	uint64_t bitmap_size;
+	
+} kafl_mem_state;
+
+static void kafl_guest_event(void *opaque, QEMUChrEvent event){
+}
+
+static void send_char(char val, void* tmp_s){
+	kafl_mem_state *s = tmp_s;
+	qemu_chr_fe_write(&s->chr, (const uint8_t *) &val, 1);
+}
+
+static int kafl_guest_can_receive(void * opaque){
+	return sizeof(int64_t);
+}
+
+static void kafl_guest_receive(void *opaque, const uint8_t * buf, int size){
+	kafl_mem_state *s = opaque;
+	int i;				
+	for(i = 0; i < size; i++){
+		switch(buf[i]){
+			case KAFL_PROTO_ACQUIRE:
+				hypercall_unlock();
+				break;
+
+			case KAFL_PROTO_RELOAD:
+				send_char(KAFL_PROTO_RELOAD, s);
+				hypercall_reload();
+				break;
+
+			/* active sampling mode */
+			case KAFL_PROTO_ENABLE_SAMPLING:	
+				hypercall_enable_filter();
+				break;
+
+			/* deactivate sampling mode */
+			case KAFL_PROTO_DISABLE_SAMPLING:
+				hypercall_disable_filter();
+				break;
+
+			/* commit sampling result */
+			case KAFL_PROTO_COMMIT_FILTER:
+				hypercall_commit_filter();
+				break;
+
+			/* finalize iteration (dump and decode PT data) in case of timeouts */
+			case KAFL_PROTO_FINALIZE:
+				pt_disable_wrapper(qemu_get_cpu(0));
+				send_char('F', s);
+				break;
+		}
+	}
+}
+
+static int kafl_guest_create_memory_bar(kafl_mem_state *s, int region_num, uint64_t bar_size, const char* file, Error **errp){
+	void * ptr;
+	int fd;
+	struct stat st;
+	
+	fd = open(file, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);
+	assert(ftruncate(fd, bar_size) == 0);
+	stat(file, &st);
+	printf("%lu %lu\n", bar_size, st.st_size);
+	
+	assert(bar_size == st.st_size);
+	ptr = mmap(0, bar_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (ptr == MAP_FAILED) {
+		error_setg_errno(errp, errno, "Failed to mmap memory");
+		return -1;
+	}
+
+	switch(region_num){
+		case 1:	pt_setup_program((void*)ptr);
+				break;
+		case 2:	pt_setup_payload((void*)ptr);
+				break;
+	}
+
+	pt_setup_snd_handler(&send_char, s);
+
+	return 0;
+}
+
+static void kafl_guest_setup_bitmap(kafl_mem_state *s, uint32_t bitmap_size){
+	void * ptr;
+	int fd;
+	struct stat st;
+	
+	fd = open(s->bitmap_file, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);
+	assert(ftruncate(fd, bitmap_size) == 0);
+	stat(s->bitmap_file, &st);
+	assert(bitmap_size == st.st_size);
+	ptr = mmap(0, bitmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+	pt_setup_bitmap((void*)ptr);
+}
+
+static void* kafl_guest_setup_filter_bitmap(kafl_mem_state *s, char* filter, uint64_t size){
+	void * ptr;
+	int fd;
+	struct stat st;
+	
+	printf("FILE: %s\n", filter);
+	fd = open(filter, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);
+	stat(filter, &st);
+	if (st.st_size != size){
+		assert(ftruncate(fd, size) == 0);
+	}
+	ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+	printf("SIZE: %lx, %p\n", size, ptr);
+	return ptr;
+	//pt_setup_bitmap((void*)ptr);
+}
+
+static void pci_kafl_guest_realize(PCIDevice *dev, Error **errp){
+	uint64_t tmp0, tmp1;
+	kafl_mem_state *s = KAFLMEM(dev);
+	void* tmp = NULL;
+
+	void* tfilter = kafl_guest_setup_filter_bitmap(s, (char*) "/dev/shm/kafl_tfilter", DEFAULT_EDGE_FILTER_SIZE);
+
+	if(s->bitmap_size <= 0){
+		s->bitmap_size = DEFAULT_KAFL_BITMAP_SIZE;
+	}
+	kafl_bitmap_size = (uint32_t)s->bitmap_size;
+	
+	if (s->data_bar_fd_0 != NULL)
+		kafl_guest_create_memory_bar(s, 1, PROGRAM_SIZE, s->data_bar_fd_0, errp);
+	if (s->data_bar_fd_1 != NULL)
+		kafl_guest_create_memory_bar(s, 2, PAYLOAD_SIZE, s->data_bar_fd_1, errp);
+	
+	// if(&s->chr)
+		qemu_chr_fe_set_handlers(&s->chr, kafl_guest_can_receive, kafl_guest_receive, kafl_guest_event, NULL, s, NULL, true);
+	if(s->bitmap_file)
+		kafl_guest_setup_bitmap(s, kafl_bitmap_size);
+
+	for(uint8_t i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(s->ip_filter[i][0] && s->ip_filter[i][1]){
+			tmp0 = CONVERT_UINT64(s->ip_filter[i][0]);
+			tmp1 = CONVERT_UINT64(s->ip_filter[i][1]);
+			if (tmp0 < tmp1){
+				tmp = NULL;
+				if(s->filter_bitmap[i]){
+					tmp = kafl_guest_setup_filter_bitmap(s, s->filter_bitmap[i], (uint64_t)(tmp1-tmp0));
+				}
+				pt_setup_ip_filters(i, tmp0, tmp1, tmp, tfilter);
+			}
+		}
+	}
+
+	if(s->irq_filter){
+	}
+
+	pt_setup_enable_hypercalls();
+}
+
+static Property kafl_guest_properties[] = {
+	DEFINE_PROP_CHR("chardev", kafl_mem_state, chr),
+	DEFINE_PROP_STRING("shm0", kafl_mem_state, data_bar_fd_0),
+	DEFINE_PROP_STRING("shm1", kafl_mem_state, data_bar_fd_1),
+	DEFINE_PROP_STRING("bitmap", kafl_mem_state, bitmap_file),
+	DEFINE_PROP_STRING("filter0", kafl_mem_state, filter_bitmap[0]),
+	DEFINE_PROP_STRING("filter1", kafl_mem_state, filter_bitmap[1]),
+	DEFINE_PROP_STRING("filter2", kafl_mem_state, filter_bitmap[2]),
+	DEFINE_PROP_STRING("filter3", kafl_mem_state, filter_bitmap[3]),
+	/* 
+	 * Since DEFINE_PROP_UINT64 is somehow broken (signed/unsigned madness),
+	 * let's use DEFINE_PROP_STRING and post-process all values by strtol...
+	 */
+	DEFINE_PROP_STRING("ip0_a", kafl_mem_state, ip_filter[0][0]),
+	DEFINE_PROP_STRING("ip0_b", kafl_mem_state, ip_filter[0][1]),
+	DEFINE_PROP_STRING("ip1_a", kafl_mem_state, ip_filter[1][0]),
+	DEFINE_PROP_STRING("ip1_b", kafl_mem_state, ip_filter[1][1]),
+	DEFINE_PROP_STRING("ip2_a", kafl_mem_state, ip_filter[2][0]),
+	DEFINE_PROP_STRING("ip2_b", kafl_mem_state, ip_filter[2][1]),
+	DEFINE_PROP_STRING("ip3_a", kafl_mem_state, ip_filter[3][0]),
+	DEFINE_PROP_STRING("ip3_b", kafl_mem_state, ip_filter[3][1]),
+	DEFINE_PROP_BOOL("irq_filter", kafl_mem_state, irq_filter, false),
+	DEFINE_PROP_UINT64("bitmap_size", kafl_mem_state, bitmap_size, DEFAULT_KAFL_BITMAP_SIZE),
+	
+	DEFINE_PROP_END_OF_LIST(),
+};
+
+static void kafl_guest_class_init(ObjectClass *klass, void *data){
+	DeviceClass *dc = DEVICE_CLASS(klass);
+	PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
+	k->realize = pci_kafl_guest_realize;
+	k->class_id = PCI_CLASS_MEMORY_RAM;
+	device_class_set_props(dc, kafl_guest_properties);
+	set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+	dc->desc = "KAFL Inter-VM shared memory";
+}
+
+static void kafl_guest_init(Object *obj){
+}
+
+static const TypeInfo kafl_guest_info = {
+	.name          = TYPE_KAFLMEM,
+	.parent        = TYPE_PCI_DEVICE,
+	.instance_size = sizeof(kafl_mem_state),
+	.instance_init = kafl_guest_init,
+	.class_init    = kafl_guest_class_init,
+};
+
+static void kafl_guest_register_types(void){
+	type_register_static(&kafl_guest_info);
+}
+
+type_init(kafl_guest_register_types)
diff --git a/pt/interface.h b/pt/interface.h
new file mode 100644
index 0000000..7c0344a
--- /dev/null
+++ b/pt/interface.h
@@ -0,0 +1,54 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef INTERFACE_H
+#define INTERFACE_H
+
+#define INTEL_PT_MAX_RANGES			4
+
+#define DEFAULT_KAFL_BITMAP_SIZE	0x10000
+#define DEFAULT_EDGE_FILTER_SIZE	0x1000000
+
+#define PROGRAM_SIZE				(16  << 20)	/* 16MB Application Data */
+#define PAYLOAD_SIZE				(128 << 10)	/* 128KB Payload Data */
+#define INFO_SIZE					(128 << 10)	/* 128KB Info Data */
+
+#define INFO_FILE					"/tmp/kAFL_info.txt"
+
+#define HOOK_INSTRUCTION			0xee
+
+#define KAFL_PROTO_ACQUIRE			'R'
+#define KAFL_PROTO_RELEASE			'D'
+
+#define KAFL_PROTO_RELOAD			'L'
+#define KAFL_PROTO_ENABLE_SAMPLING	'S'
+#define KAFL_PROTO_DISABLE_SAMPLING	'O'
+#define KAFL_PROTO_COMMIT_FILTER	'T'
+#define KAFL_PROTO_FINALIZE			'F'
+
+#define KAFL_PROTO_ENABLE_RQI_MODE	'A'
+#define KAFL_PROTO_DISABLE_RQI_MODE	'B'
+
+#define KAFL_PROTO_CRASH			'C'
+#define KAFL_PROTO_KASAN			'K'
+#define KAFL_PROTO_INFO				'I'
+
+#endif
diff --git a/pt/khash.h b/pt/khash.h
new file mode 100644
index 0000000..0d5d29a
--- /dev/null
+++ b/pt/khash.h
@@ -0,0 +1,627 @@
+/* The MIT License
+
+   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/*
+  An example:
+
+#include "khash.h"
+KHASH_MAP_INIT_INT(32, char)
+int main() {
+	int ret, is_missing;
+	khiter_t k;
+	khash_t(32) *h = kh_init(32);
+	k = kh_put(32, h, 5, &ret);
+	kh_value(h, k) = 10;
+	k = kh_get(32, h, 10);
+	is_missing = (k == kh_end(h));
+	k = kh_get(32, h, 5);
+	kh_del(32, h, k);
+	for (k = kh_begin(h); k != kh_end(h); ++k)
+		if (kh_exist(h, k)) kh_value(h, k) = 1;
+	kh_destroy(32, h);
+	return 0;
+}
+*/
+
+/*
+  2013-05-02 (0.2.8):
+
+	* Use quadratic probing. When the capacity is power of 2, stepping function
+	  i*(i+1)/2 guarantees to traverse each bucket. It is better than double
+	  hashing on cache performance and is more robust than linear probing.
+
+	  In theory, double hashing should be more robust than quadratic probing.
+	  However, my implementation is probably not for large hash tables, because
+	  the second hash function is closely tied to the first hash function,
+	  which reduce the effectiveness of double hashing.
+
+	Reference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php
+
+  2011-12-29 (0.2.7):
+
+    * Minor code clean up; no actual effect.
+
+  2011-09-16 (0.2.6):
+
+	* The capacity is a power of 2. This seems to dramatically improve the
+	  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:
+
+	   - http://code.google.com/p/ulib/
+	   - http://nothings.org/computer/judy/
+
+	* Allow to optionally use linear probing which usually has better
+	  performance for random input. Double hashing is still the default as it
+	  is more robust to certain non-random input.
+
+	* Added Wang's integer hash function (not used by default). This hash
+	  function is more robust to certain non-random input.
+
+  2011-02-14 (0.2.5):
+
+    * Allow to declare global functions.
+
+  2009-09-26 (0.2.4):
+
+    * Improve portability
+
+  2008-09-19 (0.2.3):
+
+	* Corrected the example
+	* Improved interfaces
+
+  2008-09-11 (0.2.2):
+
+	* Improved speed a little in kh_put()
+
+  2008-09-10 (0.2.1):
+
+	* Added kh_clear()
+	* Fixed a compiling error
+
+  2008-09-02 (0.2.0):
+
+	* Changed to token concatenation which increases flexibility.
+
+  2008-08-31 (0.1.2):
+
+	* Fixed a bug in kh_get(), which has not been tested previously.
+
+  2008-08-31 (0.1.1):
+
+	* Added destructor
+*/
+
+
+#ifndef __AC_KHASH_H
+#define __AC_KHASH_H
+
+/*!
+  @header
+
+  Generic hash table library.
+ */
+
+#define AC_VERSION_KHASH_H "0.2.8"
+
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+
+/* compiler specific configuration */
+
+#if UINT_MAX == 0xffffffffu
+typedef unsigned int khint32_t;
+#elif ULONG_MAX == 0xffffffffu
+typedef unsigned long khint32_t;
+#endif
+
+#if ULONG_MAX == ULLONG_MAX
+typedef unsigned long khint64_t;
+#else
+typedef unsigned long long khint64_t;
+#endif
+
+#ifndef kh_inline
+#ifdef _MSC_VER
+#define kh_inline __inline
+#else
+#define kh_inline inline
+#endif
+#endif /* kh_inline */
+
+#ifndef klib_unused
+#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)
+#define klib_unused __attribute__ ((__unused__))
+#else
+#define klib_unused
+#endif
+#endif /* klib_unused */
+
+typedef khint64_t khint_t;
+typedef khint_t khiter_t;
+
+#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)
+#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)
+#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)
+#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))
+#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))
+#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))
+#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))
+
+#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)
+
+#ifndef kroundup32
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+#ifndef kcalloc
+#define kcalloc(N,Z) calloc(N,Z)
+#endif
+#ifndef kmalloc
+#define kmalloc(Z) malloc(Z)
+#endif
+#ifndef krealloc
+#define krealloc(P,Z) realloc(P,Z)
+#endif
+#ifndef kfree
+#define kfree(P) free(P)
+#endif
+
+static const double __ac_HASH_UPPER = 0.77;
+
+#define __KHASH_TYPE(name, khkey_t, khval_t) \
+	typedef struct kh_##name##_s { \
+		khint_t n_buckets, size, n_occupied, upper_bound; \
+		khint32_t *flags; \
+		khkey_t *keys; \
+		khval_t *vals; \
+	} kh_##name##_t;
+
+#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)	 					\
+	extern kh_##name##_t *kh_init_##name(void);							\
+	extern void kh_destroy_##name(kh_##name##_t *h);					\
+	extern void kh_clear_##name(kh_##name##_t *h);						\
+	extern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); 	\
+	extern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \
+	extern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \
+	extern void kh_del_##name(kh_##name##_t *h, khint_t x);
+
+#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
+	SCOPE kh_##name##_t *kh_init_##name(void) {							\
+		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
+	}																	\
+	SCOPE void kh_destroy_##name(kh_##name##_t *h)						\
+	{																	\
+		if (h) {														\
+			kfree((void *)h->keys); kfree(h->flags);					\
+			kfree((void *)h->vals);										\
+			kfree(h);													\
+		}																\
+	}																	\
+	SCOPE void kh_clear_##name(kh_##name##_t *h)						\
+	{																	\
+		if (h && h->flags) {											\
+			memset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \
+			h->size = h->n_occupied = 0;								\
+		}																\
+	}																	\
+	SCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) 	\
+	{																	\
+		if (h->n_buckets) {												\
+			khint_t k, i, last, mask, step = 0; \
+			mask = h->n_buckets - 1;									\
+			k = __hash_func(key); i = k & mask;							\
+			last = i; \
+			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
+				i = (i + (++step)) & mask; \
+				if (i == last) return h->n_buckets;						\
+			}															\
+			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
+		} else return 0;												\
+	}																	\
+	SCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \
+	{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \
+		khint32_t *new_flags = 0;										\
+		khint_t j = 1;													\
+		{																\
+			kroundup32(new_n_buckets); 									\
+			if (new_n_buckets < 4) new_n_buckets = 4;					\
+			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
+			else { /* hash table size to be changed (shrink or expand); rehash */ \
+				new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));	\
+				if (!new_flags) return -1;								\
+				memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \
+				if (h->n_buckets < new_n_buckets) {	/* expand */		\
+					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
+					if (!new_keys) { kfree(new_flags); return -1; }		\
+					h->keys = new_keys;									\
+					if (kh_is_map) {									\
+						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
+						if (!new_vals) { kfree(new_flags); return -1; }	\
+						h->vals = new_vals;								\
+					}													\
+				} /* otherwise shrink */								\
+			}															\
+		}																\
+		if (j) { /* rehashing is needed */								\
+			for (j = 0; j != h->n_buckets; ++j) {						\
+				if (__ac_iseither(h->flags, j) == 0) {					\
+					khkey_t key = h->keys[j];							\
+					khval_t val;										\
+					khint_t new_mask;									\
+					new_mask = new_n_buckets - 1; 						\
+					if (kh_is_map) val = h->vals[j];					\
+					__ac_set_isdel_true(h->flags, j);					\
+					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
+						khint_t k, i, step = 0; \
+						k = __hash_func(key);							\
+						i = k & new_mask;								\
+						while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \
+						__ac_set_isempty_false(new_flags, i);			\
+						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
+							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
+							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
+							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
+						} else { /* write the element and jump out of the loop */ \
+							h->keys[i] = key;							\
+							if (kh_is_map) h->vals[i] = val;			\
+							break;										\
+						}												\
+					}													\
+				}														\
+			}															\
+			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
+				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
+				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
+			}															\
+			kfree(h->flags); /* free the working space */				\
+			h->flags = new_flags;										\
+			h->n_buckets = new_n_buckets;								\
+			h->n_occupied = h->size;									\
+			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
+		}																\
+		return 0;														\
+	}																	\
+	SCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \
+	{																	\
+		khint_t x;														\
+		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
+			if (h->n_buckets > (h->size<<1)) {							\
+				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
+					*ret = -1; return h->n_buckets;						\
+				}														\
+			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
+				*ret = -1; return h->n_buckets;							\
+			}															\
+		} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \
+		{																\
+			khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \
+			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
+			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
+			else {														\
+				last = i; \
+				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
+					if (__ac_isdel(h->flags, i)) site = i;				\
+					i = (i + (++step)) & mask; \
+					if (i == last) { x = site; break; }					\
+				}														\
+				if (x == h->n_buckets) {								\
+					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
+					else x = i;											\
+				}														\
+			}															\
+		}																\
+		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
+			h->keys[x] = key;											\
+			__ac_set_isboth_false(h->flags, x);							\
+			++h->size; ++h->n_occupied;									\
+			*ret = 1;													\
+		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
+			h->keys[x] = key;											\
+			__ac_set_isboth_false(h->flags, x);							\
+			++h->size;													\
+			*ret = 2;													\
+		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
+		return x;														\
+	}																	\
+	SCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)				\
+	{																	\
+		if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {			\
+			__ac_set_isdel_true(h->flags, x);							\
+			--h->size;													\
+		}																\
+	}
+
+#define KHASH_DECLARE(name, khkey_t, khval_t)		 					\
+	__KHASH_TYPE(name, khkey_t, khval_t) 								\
+	__KHASH_PROTOTYPES(name, khkey_t, khval_t)
+
+#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
+	__KHASH_TYPE(name, khkey_t, khval_t) 								\
+	__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)
+
+#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
+	KHASH_INIT2(name, static kh_inline klib_unused, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)
+
+/* --- BEGIN OF HASH FUNCTIONS --- */
+
+/*! @function
+  @abstract     Integer hash function
+  @param  key   The integer [khint32_t]
+  @return       The hash value [khint_t]
+ */
+#define kh_int_hash_func(key) (khint32_t)(key)
+/*! @function
+  @abstract     Integer comparison function
+ */
+#define kh_int_hash_equal(a, b) ((a) == (b))
+/*! @function
+  @abstract     64-bit integer hash function
+  @param  key   The integer [khint64_t]
+  @return       The hash value [khint_t]
+ */
+#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)
+/*! @function
+  @abstract     64-bit integer comparison function
+ */
+#define kh_int64_hash_equal(a, b) ((a) == (b))
+/*! @function
+  @abstract     const char* hash function
+  @param  s     Pointer to a null terminated string
+  @return       The hash value
+ */
+static kh_inline khint_t __ac_X31_hash_string(const char *s)
+{
+	khint_t h = (khint_t)*s;
+	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
+	return h;
+}
+/*! @function
+  @abstract     Another interface to const char* hash function
+  @param  key   Pointer to a null terminated string [const char*]
+  @return       The hash value [khint_t]
+ */
+#define kh_str_hash_func(key) __ac_X31_hash_string(key)
+/*! @function
+  @abstract     Const char* comparison function
+ */
+#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)
+
+static kh_inline khint_t __ac_Wang_hash(khint_t key)
+{
+    key += ~(key << 15);
+    key ^=  (key >> 10);
+    key +=  (key << 3);
+    key ^=  (key >> 6);
+    key += ~(key << 11);
+    key ^=  (key >> 16);
+    return key;
+}
+#define kh_int_hash_func2(key) __ac_Wang_hash((khint_t)key)
+
+/* --- END OF HASH FUNCTIONS --- */
+
+/* Other convenient macros... */
+
+/*!
+  @abstract Type of the hash table.
+  @param  name  Name of the hash table [symbol]
+ */
+#define khash_t(name) kh_##name##_t
+
+/*! @function
+  @abstract     Initiate a hash table.
+  @param  name  Name of the hash table [symbol]
+  @return       Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_init(name) kh_init_##name()
+
+/*! @function
+  @abstract     Destroy a hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_destroy(name, h) kh_destroy_##name(h)
+
+/*! @function
+  @abstract     Reset a hash table without deallocating memory.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_clear(name, h) kh_clear_##name(h)
+
+/*! @function
+  @abstract     Resize a hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  s     New size [khint_t]
+ */
+#define kh_resize(name, h, s) kh_resize_##name(h, s)
+
+/*! @function
+  @abstract     Insert a key to the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Key [type of keys]
+  @param  r     Extra return code: -1 if the operation failed;
+                0 if the key is present in the hash table;
+                1 if the bucket is empty (never used); 2 if the element in
+				the bucket has been deleted [int*]
+  @return       Iterator to the inserted element [khint_t]
+ */
+#define kh_put(name, h, k, r) kh_put_##name(h, k, r)
+
+/*! @function
+  @abstract     Retrieve a key from the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Key [type of keys]
+  @return       Iterator to the found element, or kh_end(h) if the element is absent [khint_t]
+ */
+#define kh_get(name, h, k) kh_get_##name(h, k)
+
+/*! @function
+  @abstract     Remove a key from the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Iterator to the element to be deleted [khint_t]
+ */
+#define kh_del(name, h, k) kh_del_##name(h, k)
+
+/*! @function
+  @abstract     Test whether a bucket contains data.
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       1 if containing data; 0 otherwise [int]
+ */
+#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))
+
+/*! @function
+  @abstract     Get key given an iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       Key [type of keys]
+ */
+#define kh_key(h, x) ((h)->keys[x])
+
+/*! @function
+  @abstract     Get value given an iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       Value [type of values]
+  @discussion   For hash sets, calling this results in segfault.
+ */
+#define kh_val(h, x) ((h)->vals[x])
+
+/*! @function
+  @abstract     Alias of kh_val()
+ */
+#define kh_value(h, x) ((h)->vals[x])
+
+/*! @function
+  @abstract     Get the start iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       The start iterator [khint_t]
+ */
+#define kh_begin(h) (khint_t)(0)
+
+/*! @function
+  @abstract     Get the end iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       The end iterator [khint_t]
+ */
+#define kh_end(h) ((h)->n_buckets)
+
+/*! @function
+  @abstract     Get the number of elements in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       Number of elements in the hash table [khint_t]
+ */
+#define kh_size(h) ((h)->size)
+
+/*! @function
+  @abstract     Get the number of buckets in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       Number of buckets in the hash table [khint_t]
+ */
+#define kh_n_buckets(h) ((h)->n_buckets)
+
+/*! @function
+  @abstract     Iterate over the entries in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  kvar  Variable to which key will be assigned
+  @param  vvar  Variable to which value will be assigned
+  @param  code  Block of code to execute
+ */
+#define kh_foreach(h, kvar, vvar, code) { khint_t __i;		\
+	for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		\
+		if (!kh_exist(h,__i)) continue;						\
+		(kvar) = kh_key(h,__i);								\
+		(vvar) = kh_val(h,__i);								\
+		code;												\
+	} }
+
+/*! @function
+  @abstract     Iterate over the values in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  vvar  Variable to which value will be assigned
+  @param  code  Block of code to execute
+ */
+#define kh_foreach_value(h, vvar, code) { khint_t __i;		\
+	for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		\
+		if (!kh_exist(h,__i)) continue;						\
+		(vvar) = kh_val(h,__i);								\
+		code;												\
+	} }
+
+/* More conenient interfaces */
+
+/*! @function
+  @abstract     Instantiate a hash set containing integer keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_INT(name)										\
+	KHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing integer keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_INT(name, khval_t)								\
+	KHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing 64-bit integer keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_INT64(name)										\
+	KHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing 64-bit integer keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_INT64(name, khval_t)								\
+	KHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)
+
+typedef const char *kh_cstr_t;
+/*! @function
+  @abstract     Instantiate a hash map containing const char* keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_STR(name)										\
+	KHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing const char* keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_STR(name, khval_t)								\
+	KHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)
+
+#endif /* __AC_KHASH_H */
diff --git a/pt/logger.c b/pt/logger.c
new file mode 100644
index 0000000..213eb01
--- /dev/null
+++ b/pt/logger.c
@@ -0,0 +1,113 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include "pt/logger.h"
+
+#ifdef SAMPLE_RAW_SINGLE
+#define SAMPLE_RAW_SINGLE_TARGET "/dev/shm/kafl_pt_%d"
+
+int sample_raw_single_id = 0;
+FILE* sample_raw_single_file = NULL;
+
+void init_sample_raw_single(uint32_t id){
+	sample_raw_single_id = id;
+	char name[256];
+	snprintf(name, 256, SAMPLE_RAW_SINGLE_TARGET, sample_raw_single_id);
+	if (sample_raw_single_file)
+		fclose(sample_raw_single_file);
+	sample_raw_single_file = fopen(name, "wb"); 
+}
+
+void sample_raw_single(void* buffer, int bytes){
+	if (sample_raw_single_file){
+		fwrite(buffer, sizeof(char), bytes, sample_raw_single_file);
+		fflush(sample_raw_single_file);
+	}
+}
+#endif
+
+#ifdef SAMPLE_RAW
+#define SAMPLE_RAW_TARGET "/tmp/sample_raw_%d"
+
+int sample_raw_id = 0;
+FILE* sample_raw_file = NULL;
+
+void init_sample_raw(void){
+	char name[256];
+	snprintf(name, 256, SAMPLE_RAW_TARGET, sample_raw_id++);
+	if (sample_raw_file)
+		fclose(sample_raw_file);
+	sample_raw_file = fopen(name, "wb"); 
+}
+
+void sample_raw(void* buffer, int bytes){
+	if (sample_raw_file)
+		fwrite(buffer, sizeof(char), bytes, sample_raw_file);
+}
+#endif
+
+#ifdef SAMPLE_DECODED
+#define SAMPLE_DECODED_TARGET "/tmp/traces/sample_decoded_%d"
+
+int sample_decoded_id = 0;
+FILE* sample_decoded_file = NULL;
+
+void init_sample_decoded(void){
+	char name[256];
+	snprintf(name, 256, SAMPLE_DECODED_TARGET, sample_decoded_id++);
+	if (sample_decoded_file)
+		fclose(sample_decoded_file);
+	sample_decoded_file = fopen(name, "w"); 
+}
+
+void sample_decoded(uint64_t addr){
+	if (sample_decoded_file)
+		fprintf(sample_decoded_file, "%lx\n", addr);
+}
+#endif
+
+#ifdef SAMPLE_DECODED_DETAILED
+#define SAMPLE_DETAILED_TARGET "/tmp/traces/sample_detailed_%d"
+
+int sample_detailed_id = 0;
+FILE* sample_detailed_file = NULL;
+
+void init_sample_decoded_detailed(void){
+	char name[256];
+	snprintf(name, 256, SAMPLE_DETAILED_TARGET, sample_detailed_id++);
+	if (sample_detailed_file)
+		fclose(sample_detailed_file);
+	sample_detailed_file = fopen(name, "w"); 
+}
+#endif
+
+void sample_decoded_detailed(const char *format, ...){
+	#ifdef SAMPLE_DECODED_DETAILED
+	va_list args;
+	va_start(args, format);
+	if (sample_detailed_file)
+		vfprintf(sample_detailed_file, format, args);
+	va_end(args);
+	#endif
+}
diff --git a/pt/logger.h b/pt/logger.h
new file mode 100644
index 0000000..30fc5b4
--- /dev/null
+++ b/pt/logger.h
@@ -0,0 +1,56 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef LOGGER_H
+#define LOGGER_H
+
+	#define CREATE_VM_IMAGE
+	//#define SAMPLE_RAW
+	//#define SAMPLE_DECODED
+	//#define SAMPLE_DECODED_DETAILED
+	//#define SAMPLE_RAW_SINGLE
+
+	#ifdef CREATE_VM_IMAGE
+		#define DECODER_MEMORY_IMAGE "/tmp/data"
+	#endif
+
+	#ifdef SAMPLE_RAW_SINGLE
+		void init_sample_raw_single(uint32_t id);
+		void sample_raw_single(void* buffer, int bytes);
+	#endif
+	
+	#ifdef SAMPLE_RAW
+		void init_sample_raw(void);
+		void sample_raw(void* buffer, int bytes);
+	#endif
+
+	#ifdef SAMPLE_DECODED
+		void init_sample_decoded(void);
+		void sample_decoded(uint64_t addr);
+	#endif
+
+	#ifdef SAMPLE_DECODED_DETAILED
+		void init_sample_decoded_detailed(void);
+	#endif
+
+	void sample_decoded_detailed(const char *format, ...);
+
+#endif
diff --git a/pt/memory_access.c b/pt/memory_access.c
new file mode 100644
index 0000000..f9ad00b
--- /dev/null
+++ b/pt/memory_access.c
@@ -0,0 +1,115 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "memory_access.h"
+
+#define x86_64_PAGE_SIZE    	0x1000
+#define x86_64_PAGE_MASK   		~(x86_64_PAGE_SIZE - 1)
+
+bool read_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu){
+	uint8_t tmp_buf[x86_64_PAGE_SIZE];
+	MemTxAttrs attrs;
+	MemTxResult res;
+	hwaddr phys_addr;
+	int asidx;
+	uint64_t counter, l;
+	int i = 0;
+	
+	counter = size;
+	
+	//cpu_synchronize_state(cpu);
+	kvm_cpu_synchronize_state(cpu);
+
+	/* copy per page */
+	while(counter != 0){
+		
+		l = x86_64_PAGE_SIZE;
+		if (l > counter)
+		    l = counter;
+		
+		asidx = cpu_asidx_from_attrs(cpu, MEMTXATTRS_UNSPECIFIED);
+		attrs = MEMTXATTRS_UNSPECIFIED;
+		phys_addr = cpu_get_phys_page_attrs_debug(cpu, (address & x86_64_PAGE_MASK), &attrs);
+		if (phys_addr == -1) {
+			printf("Error: cannot read from unmapped GVA 0x%lx\n", address);
+			return false;
+		}
+		
+		phys_addr += (address & ~x86_64_PAGE_MASK);	
+		res = address_space_rw(cpu_get_address_space(cpu, asidx), phys_addr, MEMTXATTRS_UNSPECIFIED, tmp_buf, l, 0);
+		if (res != MEMTX_OK) {
+			printf("Error: failed to read from GVA 0x%lx (GPA 0x%lx)\n", address, phys_addr);
+			return false;
+		}
+		
+		memcpy(data+(i*x86_64_PAGE_SIZE), tmp_buf, l);
+		
+		i++;
+		address += l;
+		counter -= l;
+	}
+	
+	return true;
+}
+
+
+bool write_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu)
+{
+	/* Todo: later &address_space_memory + phys_addr -> mmap SHARED */
+	int asidx;
+	MemTxAttrs attrs;
+    hwaddr phys_addr;
+    MemTxResult res;
+
+    uint64_t counter, l, i;
+
+    counter = size;
+	while(counter != 0){
+		l = x86_64_PAGE_SIZE;
+        if (l > counter)
+            l = counter;
+
+	kvm_cpu_synchronize_state(cpu);
+        //cpu_synchronize_state(cpu);
+        asidx = cpu_asidx_from_attrs(cpu, MEMTXATTRS_UNSPECIFIED);
+        attrs = MEMTXATTRS_UNSPECIFIED;
+        phys_addr = cpu_get_phys_page_attrs_debug(cpu, (address & x86_64_PAGE_MASK), &attrs);
+
+        if (phys_addr == -1){
+            printf("Error: cannot write to unmapped GVA 0x%lx\n", address);
+            return false;
+        }
+        
+        phys_addr += (address & ~x86_64_PAGE_MASK);   
+        res = address_space_rw(cpu_get_address_space(cpu, asidx), phys_addr, MEMTXATTRS_UNSPECIFIED, data, l, true);
+        if (res != MEMTX_OK){
+            printf("Error: failed to write to GVA 0x%lx (GPA 0x%lx)\n", address, phys_addr);
+            return false;
+        }   
+
+        i++;
+        data += l;
+        address += l;
+        counter -= l;
+	}
+
+	return true;
+}
diff --git a/pt/memory_access.h b/pt/memory_access.h
new file mode 100644
index 0000000..cdb1ce0
--- /dev/null
+++ b/pt/memory_access.h
@@ -0,0 +1,34 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef MEMORY_ACCESS_H
+#define MEMORY_ACCESS_H
+
+#include "qemu/osdep.h"
+#include <linux/kvm.h>
+#include "hw/core/cpu.h"
+#include "sysemu/kvm_int.h"
+
+bool read_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu);
+bool write_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu);
+
+#endif
+
diff --git a/pt/meson.build b/pt/meson.build
new file mode 100644
index 0000000..cb0e97d
--- /dev/null
+++ b/pt/meson.build
@@ -0,0 +1,16 @@
+vmx_pt = ss.source_set()
+vmx_pt.add(files(
+  'memory_access.c',
+  'decoder.c',
+  'tnt_cache.c',
+  'disassembler.c',
+  'logger.c',
+  'hypercall.c',
+  'filter.c',
+  'pt.c',
+  'interface.c',
+))
+
+vmx_pt.add(capstone)
+
+specific_ss.add_all(when: 'CONFIG_PROCESSOR_TRACE', if_true: vmx_pt)
diff --git a/pt/pt.c b/pt/pt.c
new file mode 100644
index 0000000..41a34b1
--- /dev/null
+++ b/pt/pt.c
@@ -0,0 +1,353 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "qemu/osdep.h"
+#include <linux/kvm.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include "cpu.h"
+#include "pt.h"
+#include "pt/decoder.h"
+#include "exec/memory.h"
+#include "sysemu/kvm_int.h"
+#include "sysemu/kvm.h"
+#include "sysemu/cpus.h"
+#include "pt/hypercall.h"
+#include "pt/logger.h"
+#include "pt/memory_access.h"
+#include "pt/interface.h"
+
+extern uint32_t kafl_bitmap_size;
+uint8_t* bitmap = NULL;
+uint64_t last_ip = 0ULL;
+
+static void pt_set(CPUState *cpu, run_on_cpu_data arg){
+	asm volatile("" ::: "memory");
+}
+
+static inline int pt_cmd_hmp_context(CPUState *cpu, uint64_t cmd){
+	cpu->pt_ret = -1;
+	if(pt_hypercalls_enabled()){
+		printf("Error: HMP commands are ignored if kafl tracing mode is enabled (-kafl)!\n");
+	}
+	else{
+		cpu->pt_cmd = cmd;
+		run_on_cpu(cpu, pt_set, RUN_ON_CPU_NULL);
+	}
+	return cpu->pt_ret;
+}
+
+static int pt_cmd(CPUState *cpu, uint64_t cmd, bool hmp_mode){
+	if (hmp_mode){
+		return pt_cmd_hmp_context(cpu, cmd);
+	}
+	else {
+		cpu->pt_cmd = cmd;
+		pt_pre_kvm_run(cpu);
+		return cpu->pt_ret;
+	}
+}
+
+static inline int pt_ioctl(int fd, unsigned long request, unsigned long arg){
+	if (!fd){
+		return -EINVAL;
+	}
+	return ioctl(fd, request, arg);
+}
+
+void pt_setup_bitmap(void* ptr){
+	bitmap = (uint8_t*)ptr;
+}
+
+static void pt_reset_bitmap(void){
+	uint32_t i;
+	if(bitmap){
+		last_ip = 0ULL;
+		for(i = 0; i < kafl_bitmap_size; i++){
+			bitmap[i] = 0xff;
+		}
+	}
+}
+
+static inline uint64_t mix_bits(uint64_t v) {
+  v ^= (v >> 31);
+  v *= 0x7fb5d329728ea185;
+  v ^= (v >> 27);
+  v *= 0x81dadef4bc2dd44d;
+  v ^= (v >> 33);
+  return v;
+}
+
+static void pt_bitmap(uint64_t addr){
+	uint32_t transition_value = 0;
+	#ifdef SAMPLE_DECODED
+	sample_decoded(addr);
+	#endif
+	if(bitmap){		
+		/* vertex filter */
+		hypercall_submit_address(addr);
+		if(!hypercall_check_tuple(addr, last_ip)){
+			/* edge filter */
+			addr = mix_bits(addr);
+			transition_value = (addr ^ (last_ip >> 1)) & 0xffffff;
+			hypercall_submit_transition(transition_value);
+			if(!hypercall_check_transition(transition_value)){
+				/* apply transition to kAFL bitmap */
+				bitmap[transition_value & (kafl_bitmap_size-1)]++;
+			}
+		}
+		else{
+			return;
+		}
+	}
+	last_ip = addr; 
+}
+
+void pt_dump(CPUState *cpu, int bytes){
+#ifdef SAMPLE_RAW
+	sample_raw(cpu->pt_mmap, bytes);
+#endif
+#ifdef SAMPLE_RAW_SINGLE
+	sample_raw_single(cpu->pt_mmap, bytes);
+#endif
+	for(uint8_t i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(cpu->pt_ip_filter_enabled[i]){
+			if (cpu->pt_target_file){
+				fwrite(cpu->pt_mmap, sizeof(char), bytes, cpu->pt_target_file);
+			}
+			decode_buffer(cpu->pt_decoder_state[i], cpu->pt_mmap, bytes);
+		}
+	}
+	cpu->trace_size += bytes;
+}
+
+
+int pt_enable(CPUState *cpu, bool hmp_mode){
+#ifdef SAMPLE_RAW
+	init_sample_raw();
+#endif
+#ifdef SAMPLE_RAW_SINGLE
+	init_sample_raw_single(getpid());
+#endif
+#ifdef SAMPLE_DECODED
+	init_sample_decoded();
+#endif
+#ifdef SAMPLE_DECODED_DETAILED
+	init_sample_decoded_detailed();
+#endif
+	pt_reset_bitmap();
+	return pt_cmd(cpu, KVM_VMX_PT_ENABLE, hmp_mode);
+}
+	
+int pt_disable(CPUState *cpu, bool hmp_mode){
+	for(uint8_t i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		if(cpu->pt_ip_filter_enabled[i]){
+			pt_decoder_flush(cpu->pt_decoder_state[i]);
+		}
+	}
+	return pt_cmd(cpu, KVM_VMX_PT_DISABLE, hmp_mode);
+	
+}
+
+int pt_set_cr3(CPUState *cpu, uint64_t val, bool hmp_mode){
+	int r = 0;
+	if (cpu->pt_enabled){
+		return -EINVAL;
+	}
+	cpu->pt_c3_filter = val;
+	r += pt_cmd(cpu, KVM_VMX_PT_CONFIGURE_CR3, hmp_mode);
+	r += pt_cmd(cpu, KVM_VMX_PT_ENABLE_CR3, hmp_mode);
+	return r;
+}
+
+int pt_enable_ip_filtering(CPUState *cpu, uint8_t addrn, uint64_t ip_a, uint64_t ip_b, bool hmp_mode){
+	int r = 0;
+	uint8_t* buf;
+
+	if(addrn > 3){
+		return -1;
+	}
+
+	if (cpu->pt_enabled){
+		return -EINVAL;
+	}
+		
+	if(ip_a > ip_b){
+		printf("FAIL 1\n");
+		return -EINVAL;
+	}
+
+	if(cpu->pt_ip_filter_enabled[addrn]){
+		pt_disable_ip_filtering(cpu, addrn, hmp_mode);
+	}
+
+	buf = malloc(ip_b-ip_a);
+	if(!read_virtual_memory(ip_a, buf, ip_b-ip_a, cpu)){
+		printf("FAIL 2\n");
+		free(buf);
+		return -EINVAL;
+	}
+
+#ifdef CREATE_VM_IMAGE
+	FILE* pt_file = fopen(DECODER_MEMORY_IMAGE, "wb");
+	fwrite(buf, sizeof(uint8_t), ip_b-ip_a, pt_file);
+	fclose(pt_file);
+#endif
+
+
+	printf("--> %d %lx %lx\n", addrn, ip_a, ip_b);
+	
+	switch(addrn){
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+			cpu->pt_ip_filter_a[addrn] = ip_a;
+			cpu->pt_ip_filter_b[addrn] = ip_b;
+			r += pt_cmd(cpu, KVM_VMX_PT_CONFIGURE_ADDR0+addrn, hmp_mode);
+			r += pt_cmd(cpu, KVM_VMX_PT_ENABLE_ADDR0+addrn, hmp_mode);
+			cpu->pt_ip_filter_enabled[addrn] = true;
+			cpu->pt_decoder_state[addrn] = pt_decoder_init(buf, ip_a, ip_b, &pt_bitmap);
+			break;
+		default:
+			r = -EINVAL;
+	}
+	return r;
+}
+
+int pt_disable_ip_filtering(CPUState *cpu, uint8_t addrn, bool hmp_mode){
+	int r = 0;
+	switch(addrn){
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+			r = pt_cmd(cpu, KVM_VMX_PT_DISABLE_ADDR0+addrn, hmp_mode);
+			if(cpu->pt_ip_filter_enabled[addrn]){
+				cpu->pt_ip_filter_enabled[addrn] = false;
+				pt_decoder_destroy(cpu->pt_decoder_state[addrn]);
+			}
+			break;
+		default:
+			r = -EINVAL;
+	}
+	return r;
+}
+
+void pt_kvm_init(CPUState *cpu){
+	int i;
+
+	cpu->pt_cmd = 0;
+	cpu->pt_arg = 0;
+	cpu->pt_enabled = false;
+	cpu->pt_fd = 0;
+	cpu->pt_features = 0;
+
+	for(i = 0; i < INTEL_PT_MAX_RANGES; i++){
+		cpu->pt_ip_filter_enabled[i] = false;
+		cpu->pt_ip_filter_a[i] = 0x0;
+		cpu->pt_ip_filter_b[i] = 0x0;
+		cpu->pt_decoder_state[i] = NULL;
+	}
+
+	cpu->pt_c3_filter = 0;
+	cpu->pt_target_file = NULL;
+	cpu->overflow_counter = 0;
+	cpu->trace_size = 0;
+	cpu->reload_pending = false;
+}
+
+struct vmx_pt_filter_iprs {
+	__u64 a;
+	__u64 b;
+};
+
+void pt_pre_kvm_run(CPUState *cpu){
+	int ret;
+	struct vmx_pt_filter_iprs filter_iprs;
+	
+	if (!cpu->pt_fd) {
+		cpu->pt_fd = kvm_vcpu_ioctl(cpu, KVM_VMX_PT_SETUP_FD, (unsigned long)0);
+		ret = ioctl(cpu->pt_fd, KVM_VMX_PT_GET_TOPA_SIZE, (unsigned long)0x0);
+		cpu->pt_mmap = mmap(0, ret, PROT_READ, MAP_SHARED, cpu->pt_fd, 0);
+	}
+	
+	if (cpu->pt_cmd){
+		switch(cpu->pt_cmd){
+			case KVM_VMX_PT_ENABLE:
+				if (cpu->pt_fd){
+					if (!ioctl(cpu->pt_fd, cpu->pt_cmd, cpu->pt_arg)){
+						cpu->pt_enabled = true;
+					}
+				}
+				break;
+			case KVM_VMX_PT_DISABLE:
+				if (cpu->pt_fd){
+					ret = ioctl(cpu->pt_fd, cpu->pt_cmd, cpu->pt_arg);
+					if (ret > 0){
+						pt_dump(cpu, ret);
+						cpu->pt_enabled = false;
+					}
+				}
+				break;
+			
+			/* ip filtering configuration */	
+			case KVM_VMX_PT_CONFIGURE_ADDR0:
+			case KVM_VMX_PT_CONFIGURE_ADDR1:
+			case KVM_VMX_PT_CONFIGURE_ADDR2:
+			case KVM_VMX_PT_CONFIGURE_ADDR3:
+				filter_iprs.a = cpu->pt_ip_filter_a[(cpu->pt_cmd)-KVM_VMX_PT_CONFIGURE_ADDR0];
+	   			filter_iprs.b = cpu->pt_ip_filter_b[(cpu->pt_cmd)-KVM_VMX_PT_CONFIGURE_ADDR0];
+				ret = pt_ioctl(cpu->pt_fd, cpu->pt_cmd, (unsigned long)&filter_iprs);
+				break;
+			case KVM_VMX_PT_ENABLE_ADDR0:
+			case KVM_VMX_PT_ENABLE_ADDR1:
+			case KVM_VMX_PT_ENABLE_ADDR2:
+			case KVM_VMX_PT_ENABLE_ADDR3:
+				ret = pt_ioctl(cpu->pt_fd, cpu->pt_cmd, (unsigned long)0);
+				break;
+			case KVM_VMX_PT_CONFIGURE_CR3:
+				ret = pt_ioctl(cpu->pt_fd, cpu->pt_cmd, cpu->pt_c3_filter);
+				break;
+			case KVM_VMX_PT_ENABLE_CR3:
+				ret = pt_ioctl(cpu->pt_fd, cpu->pt_cmd, (unsigned long)0);
+				break;
+			default:
+				if (cpu->pt_fd){
+					ioctl(cpu->pt_fd, cpu->pt_cmd, cpu->pt_arg);  
+				}
+				break;
+			}
+		cpu->pt_cmd = 0;
+		cpu->pt_ret = 0;
+	}
+}
+
+void pt_post_kvm_run(CPUState *cpu){
+	int overflow;
+	if (cpu->pt_enabled){
+		overflow = ioctl(cpu->pt_fd, KVM_VMX_PT_CHECK_TOPA_OVERFLOW, (unsigned long)0);
+		if (overflow > 0){
+			cpu->overflow_counter++;
+			pt_dump(cpu, overflow);
+		}    
+	}
+}
diff --git a/pt/pt.h b/pt/pt.h
new file mode 100644
index 0000000..c1b661d
--- /dev/null
+++ b/pt/pt.h
@@ -0,0 +1,38 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PT_H
+#define PT_H
+
+void pt_setup_bitmap(void* ptr);
+
+int pt_enable(CPUState *cpu, bool hmp_mode);
+int pt_disable(CPUState *cpu, bool hmp_mode);
+int pt_enable_ip_filtering(CPUState *cpu, uint8_t addrn, uint64_t ip_a, uint64_t ip_b, bool hmp_mode);
+int pt_disable_ip_filtering(CPUState *cpu, uint8_t addrn, bool hmp_mode);
+int pt_set_cr3(CPUState *cpu, uint64_t val, bool hmp_mode);
+
+void pt_kvm_init(CPUState *cpu);
+void pt_pre_kvm_run(CPUState *cpu);
+void pt_post_kvm_run(CPUState *cpu);
+
+void pt_dump(CPUState *cpu, int bytes);
+#endif
\ No newline at end of file
diff --git a/pt/tnt_cache.c b/pt/tnt_cache.c
new file mode 100644
index 0000000..6c88d49
--- /dev/null
+++ b/pt/tnt_cache.c
@@ -0,0 +1,148 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "tnt_cache.h"
+
+#define BIT(x)				(1ULL << (x))
+#define NOT_TAKEN			0
+#define TAKEN				1
+#define TNT_EMPTY			2
+
+#define SHORT_TNT_OFFSET	1
+#define SHORT_TNT_MAX_BITS	8-1-SHORT_TNT_OFFSET
+
+#define LONG_TNT_OFFSET		16
+#define LONG_TNT_MAX_BITS	64-1-LONG_TNT_OFFSET
+
+static inline uint8_t asm_bsr(uint64_t x){
+	asm ("bsrq %0, %0" : "=r" (x) : "0" (x));
+	return x;
+}
+
+static void free_tnt_cache(tnt_cache_t* self){
+	tnt_cache_obj* tmp;
+	tnt_cache_obj* new;
+	if(self->head){
+		new = self->head;
+		tmp = NULL;
+		while(new){
+			tmp = new;
+			new = new->next;
+			free(tmp);
+		}
+		self->head = NULL;
+		self->next_node = NULL;
+	}
+}
+
+static inline void free_tnt_cache_obj(tnt_cache_t* self){
+	tnt_cache_obj* tmp;
+	tmp = self->head;
+	self->head = self->head->next;
+	free(tmp);
+}
+
+uint8_t process_tnt_cache(tnt_cache_t* self){
+	uint8_t ret;
+	if(self->head){
+		/* Short TNT */
+		if (self->head->bits <= SHORT_TNT_MAX_BITS){
+			ret = !!(self->head->data & BIT((SHORT_TNT_OFFSET-1) + self->head->bits - self->head->processed));
+		}
+		/* Long TNT */
+		else {
+			ret = !!(self->head->data & BIT((LONG_TNT_OFFSET-1) + (self->head->bits - self->head->processed)));
+		}
+			
+		self->counter--;
+		self->head->processed++;
+		
+		/* Free this TNT cache object if consumed... */
+		if (self->head->processed == self->head->bits){
+			if(self->next_node == self->head){
+				free_tnt_cache(self);
+			} 
+			else {
+				free_tnt_cache_obj(self);	
+			}
+		}
+		return ret;
+	} 
+	
+	/* TNT cache seems to be empty... */
+	return TNT_EMPTY;
+}
+
+
+void append_tnt_cache(tnt_cache_t* self, bool short_tnt, uint64_t data){
+	tnt_cache_obj* new;
+	uint8_t bits;
+
+	if(short_tnt){
+		/* Short TNT magic  */ 
+		bits = asm_bsr(data)-SHORT_TNT_OFFSET;
+	}
+	else{
+		/* Long TNT magic  */ 
+		bits = asm_bsr(data)-LONG_TNT_MAX_BITS;
+	}
+	
+	if (!bits){
+		/* trailing 1 not found... */
+		return;
+	}
+	
+	new = malloc(sizeof(tnt_cache_obj));
+	new->bits = bits;
+	if(self->next_node){
+		self->next_node->next = new;
+	}
+	else{
+		self->head = new;
+	}
+	new->processed = 0;
+	new->data = data;
+	new->next = NULL;
+	self->next_node = new;
+	self->counter += bits;
+}
+
+bool is_empty_tnt_cache(tnt_cache_t* self){
+	return (bool)!!(self->counter);
+}
+
+int count_tnt(tnt_cache_t* self){
+	return self->counter;
+}
+
+tnt_cache_t* tnt_cache_init(void){
+	tnt_cache_t* res = malloc(sizeof(tnt_cache_t));
+	res->head = NULL;
+	res->next_node = NULL;
+	res->counter = 0;
+	return res;
+}
+
+void tnt_cache_destroy(tnt_cache_t* self){
+	free_tnt_cache(self);
+	free(self);
+}
+
diff --git a/pt/tnt_cache.h b/pt/tnt_cache.h
new file mode 100644
index 0000000..81ba4f4
--- /dev/null
+++ b/pt/tnt_cache.h
@@ -0,0 +1,61 @@
+/*
+
+Copyright (C) 2017 Sergej Schumilo
+
+This file is part of QEMU-PT (kAFL).
+
+QEMU-PT is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+QEMU-PT is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with QEMU-PT.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef TNT_CACHE_H
+#define TNT_CACHE_H
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#define NOT_TAKEN			0
+#define TAKEN				1
+#define TNT_EMPTY			2
+
+#define SHORT_TNT_OFFSET	1
+#define SHORT_TNT_MAX_BITS	8-1-SHORT_TNT_OFFSET
+
+#define LONG_TNT_OFFSET		16
+#define LONG_TNT_MAX_BITS	64-1-LONG_TNT_OFFSET
+
+typedef struct tnt_cache_obj{
+	uint8_t bits;
+	uint64_t data;
+	uint8_t processed;
+	struct tnt_cache_obj* next;
+}tnt_cache_obj;
+
+typedef struct tnt_cache_s{
+	tnt_cache_obj* head;
+	tnt_cache_obj* next_node;
+	uint8_t counter;
+} tnt_cache_t;
+
+tnt_cache_t* tnt_cache_init(void);
+void tnt_cache_destroy(tnt_cache_t* self);
+
+bool is_empty_tnt_cache(tnt_cache_t* self);
+int count_tnt(tnt_cache_t* self);
+uint8_t process_tnt_cache(tnt_cache_t* self);
+void append_tnt_cache(tnt_cache_t* self, bool short_tnt, uint64_t data);
+
+#endif 
\ No newline at end of file
diff --git a/scripts/meson-buildoptions.sh b/scripts/meson-buildoptions.sh
index 30e1f25..b24a9b9 100644
--- a/scripts/meson-buildoptions.sh
+++ b/scripts/meson-buildoptions.sh
@@ -139,6 +139,7 @@ meson_options_help() {
   printf "%s\n" '  pa              PulseAudio sound support'
   printf "%s\n" '  parallels       parallels image format support'
   printf "%s\n" '  png             PNG support with libpng'
+  printf "%s\n" '  pt              Guest tracing via vmx_pt'
   printf "%s\n" '  pvrdma          Enable PVRDMA support'
   printf "%s\n" '  qcow1           qcow1 image format support'
   printf "%s\n" '  qed             qed image format support'
@@ -381,6 +382,8 @@ _meson_option_parse() {
     --disable-profiler) printf "%s" -Dprofiler=false ;;
     --enable-pvrdma) printf "%s" -Dpvrdma=enabled ;;
     --disable-pvrdma) printf "%s" -Dpvrdma=disabled ;;
+    --enable-pt) printf "%s" -Dvmx_pt=enabled ;;
+    --disable-pt) printf "%s" -Dvmx_pt=disabled ;;
     --enable-qcow1) printf "%s" -Dqcow1=enabled ;;
     --disable-qcow1) printf "%s" -Dqcow1=disabled ;;
     --enable-qed) printf "%s" -Dqed=enabled ;;
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index 3359aaf..0a6aca9 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -60,6 +60,13 @@
 #include "sysemu/tpm.h"
 #include "trace.h"
 
+#ifdef CONFIG_PROCESSOR_TRACE
+#include "migration/snapshot.h"
+#include "pt/pt.h"
+#include "pt/hypercall.h"
+#include "sysemu/kvm.h"
+#endif
+
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
@@ -337,6 +344,10 @@ void vm_state_notify(bool running, RunState state)
 }
 
 static ShutdownCause reset_requested;
+#ifdef CONFIG_PROCESSOR_TRACE
+static int reload_requested;
+char* loadvm_global = NULL;
+#endif
 static ShutdownCause shutdown_requested;
 static int shutdown_signal;
 static pid_t shutdown_pid;
@@ -429,6 +440,15 @@ static int qemu_debug_requested(void)
     return r;
 }
 
+#ifdef CONFIG_PROCESSOR_TRACE
+static int qemu_reload_requested(void)
+{
+    int r = reload_requested;
+    reload_requested = 0;
+    return r;
+}
+#endif
+
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
@@ -525,6 +545,13 @@ void qemu_system_guest_crashloaded(GuestPanicInformation *info)
 
 void qemu_system_reset_request(ShutdownCause reason)
 {
+#ifdef CONFIG_PROCESSOR_TRACE
+    if (kvm_enabled()) {
+        hypercall_unlock();
+        pt_disable(qemu_get_cpu(0), false);
+    }
+#endif
+
     if (reboot_action == REBOOT_ACTION_SHUTDOWN &&
         reason != SHUTDOWN_CAUSE_SUBSYSTEM_RESET) {
         shutdown_requested = reason;
@@ -538,6 +565,19 @@ void qemu_system_reset_request(ShutdownCause reason)
     qemu_notify_event();
 }
 
+#ifdef CONFIG_PROCESSOR_TRACE
+void qemu_system_reload_request(void)
+{
+    if (kvm_enabled()) {
+        hypercall_unlock();
+        pt_disable(qemu_get_cpu(0), false);
+    }
+    reload_requested = 1;
+    cpu_stop_current();
+    qemu_notify_event();
+}
+#endif
+
 static void qemu_system_suspend(void)
 {
     pause_all_vcpus();
@@ -548,6 +588,13 @@ static void qemu_system_suspend(void)
 
 void qemu_system_suspend_request(void)
 {
+#ifdef CONFIG_PROCESSOR_TRACE
+    if (kvm_enabled()) {
+        hypercall_unlock();
+        pt_disable(qemu_get_cpu(0), false);
+    }
+#endif
+
     if (runstate_check(RUN_STATE_SUSPENDED)) {
         return;
     }
@@ -619,6 +666,13 @@ void qemu_system_killed(int signal, pid_t pid)
 
 void qemu_system_shutdown_request(ShutdownCause reason)
 {
+#ifdef CONFIG_PROCESSOR_TRACE
+    if (kvm_enabled()) {
+        hypercall_unlock();
+        pt_disable(qemu_get_cpu(0), false);
+    }
+#endif
+
     trace_qemu_system_shutdown_request(reason);
     replay_shutdown_request(reason);
     shutdown_requested = reason;
@@ -665,6 +719,23 @@ static bool main_loop_should_exit(int *status)
     RunState r;
     ShutdownCause request;
 
+#ifdef CONFIG_PROCESSOR_TRACE
+    Error *err = NULL;
+    if (qemu_reload_requested()) {
+        if (loadvm_global) {
+            vm_stop(RUN_STATE_RESTORE_VM);
+            // if (load_vmstate(loadvm_global) == 0) {
+            if (load_snapshot(loadvm_global, NULL, false, NULL, &err)) {
+                vm_start();
+            } else {
+                error_report_err(err);
+                error_report("Could not perform VM reload");
+            }
+            return false; 
+        }   
+    }
+#endif
+
     if (qemu_debug_requested()) {
         vm_stop(RUN_STATE_DEBUG);
     }
diff --git a/softmmu/vl.c b/softmmu/vl.c
index ea20b23..8c04590 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -156,6 +156,10 @@ typedef struct DeviceOption {
     QTAILQ_ENTRY(DeviceOption) next;
 } DeviceOption;
 
+#ifdef CONFIG_PROCESSOR_TRACE
+extern char* loadvm_global;
+#endif
+
 static const char *cpu_option;
 static const char *mem_path;
 static const char *incoming;
@@ -830,7 +834,7 @@ static MachineClass *find_default_machine(GSList *machines)
 
 static void version(void)
 {
-    printf("QEMU emulator version " QEMU_FULL_VERSION "\n"
+    printf("QEMU-PT emulator version " QEMU_FULL_VERSION "\n"
            QEMU_COPYRIGHT "\n");
 }
 
@@ -3158,6 +3162,9 @@ void qemu_init(int argc, char **argv)
                 break;
             case QEMU_OPTION_loadvm:
                 loadvm = optarg;
+#ifdef CONFIG_PROCESSOR_TRACE
+                loadvm_global = (char*)optarg;
+#endif
                 break;
             case QEMU_OPTION_full_screen:
                 dpy.has_full_screen = true;
-- 
2.40.1

